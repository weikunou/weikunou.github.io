<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity3D 存档读档</title>
    <link href="/2024/04/21/unity-save-data/"/>
    <url>/2024/04/21/unity-save-data/</url>
    
    <content type="html"><![CDATA[<p>Unity3D json 存档读档功能。</p><span id="more"></span><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>游戏存档通常是把存在于内存中的对象，通过序列化，把对象中的数据存储到文件中，实现数据的持久化。</p><p>游戏读档则是把文件中的数据，通过反序列化，重新生成内存中的对象。</p><p>存档的格式，一般使用 json 存储，也可以使用二进制、XML等。</p><h1 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h1><p>首先，需要安装一个 json 库，在 Package Manager 窗口中，搜索 Newtonsoft Json 进行安装。</p><p>也可以使用其他 json 库，Newtonsoft Json 的优点是可以很好地序列化字典。</p><p>接着，创建一个 GameData 类，标记为可序列化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameData</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> playerID;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GameData</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        playerID = <span class="hljs-number">100001</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后创建一个 DataManager 类，用来管理存档。</p><p>这里的 SavePath 添加了平台宏定义，如果是在 unity editor 中运行，就直接存储到 Assets 文件夹中，其他平台则是存储到可读写的数据目录中。</p><p>通过调用 <code>JsonConvert.SerializeObject</code> 方法，把 gameData 序列化成 json 字符串，再使用 <code>StreamWriter</code> 写入本地文件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> Newtonsoft.Json;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameData gameData;<br><br>    <span class="hljs-built_in">string</span> SavePath<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_EDITOR</span><br>            <span class="hljs-keyword">return</span> Application.dataPath + <span class="hljs-string">&quot;/SaveData.json&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-keyword">return</span> Application.persistentDataPath + <span class="hljs-string">&quot;/SaveData.json&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>            </span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Save();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Save</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">string</span> json = JsonConvert.SerializeObject(gameData);<br>        StreamWriter sw = <span class="hljs-keyword">new</span> StreamWriter(SavePath);<br>        sw.Write(json);<br>        sw.Close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行游戏之后，停止运行，刷新工程资源目录，可以看到 Assets 文件夹下多出了一个 SaveData.json 文件。</p><p>json 的内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;playerID&quot;</span>:<span class="hljs-number">100001</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="读档"><a href="#读档" class="headerlink" title="读档"></a>读档</h1><p>读档的时候，要先判断本地是否有存档文件，再进行文件的读取和反序列化，还原 gameData 数据对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Load</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (File.Exists(SavePath))<br>        &#123;<br>            StreamReader sr = <span class="hljs-keyword">new</span> StreamReader(SavePath);<br>            <span class="hljs-built_in">string</span> json = sr.ReadToEnd();<br>            sr.Close();<br>            gameData = JsonConvert.DeserializeObject&lt;GameData&gt;(json);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在游戏开始时，先读档，再修改数据对象，再次存档。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Load();<br>        gameData.playerID = <span class="hljs-number">100002</span>;<br>        Save();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，json 的内容改变了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;playerID&quot;</span>:<span class="hljs-number">100002</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据对象扩展"><a href="#数据对象扩展" class="headerlink" title="数据对象扩展"></a>数据对象扩展</h1><p>目前 GameData 中只有一个 playerID，实际上可以再定义更多的数据类，统一放到 GameData 中作为成员字段。</p><p>例如，定义一个 DataPlayer 类，保存玩家的数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataPlayer</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> playerID;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> playerName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> health;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataPlayer</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        playerID = <span class="hljs-number">100001</span>;<br>        playerName = <span class="hljs-string">&quot;Player&quot;</span>;<br>        health = <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把 DataPlayer 放到 GameData 中，在构造函数中要记得实例化对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameData</span><br>&#123;<br>    <span class="hljs-keyword">public</span> DataPlayer dataPlayer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GameData</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        dataPlayer = <span class="hljs-keyword">new</span> DataPlayer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>游戏开始时，修改一下玩家名字，再存档。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Load();<br>        gameData.dataPlayer.playerName = <span class="hljs-string">&quot;起个名字很难&quot;</span>;<br>        Save();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时，json 的内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;dataPlayer&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;playerID&quot;</span>: <span class="hljs-number">100001</span>,<br>        <span class="hljs-attr">&quot;playerName&quot;</span>: <span class="hljs-string">&quot;起个名字很难&quot;</span>,<br>        <span class="hljs-attr">&quot;health&quot;</span>: <span class="hljs-number">100</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D ScriptableObject</title>
    <link href="/2024/04/14/unity-scriptable-object/"/>
    <url>/2024/04/14/unity-scriptable-object/</url>
    
    <content type="html"><![CDATA[<p>Unity3D ScriptableObject 的使用。</p><span id="more"></span><h1 id="创建-SO"><a href="#创建-SO" class="headerlink" title="创建 SO"></a>创建 SO</h1><p>ScriptableObject 是 unity 提供的一个数据存储类。</p><p>使用时，只需创建一个类继承 ScriptableObject，加上创建菜单代码，就可以在资源文件夹创建 SO 脚本对应的数据文件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">CreateAssetMenu(fileName = <span class="hljs-meta-string">&quot;SOConfig&quot;</span>, menuName = <span class="hljs-meta-string">&quot;SOConfig&quot;</span>, order = 0)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SOConfig</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> version;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建数据文件：</p><p><img src="/../images/unity-scriptable-object/%E5%88%9B%E5%BB%BASO%E6%96%87%E4%BB%B6.png"></p><p>填写数据：</p><p><img src="/../images/unity-scriptable-object/%E9%85%8D%E7%BD%AESO%E6%95%B0%E6%8D%AE.png"></p><h1 id="获取-SO-数据"><a href="#获取-SO-数据" class="headerlink" title="获取 SO 数据"></a>获取 SO 数据</h1><p>可以直接引用数据文件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SODemo</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> SOConfig config;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">$&quot;version = <span class="hljs-subst">&#123;config.version&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/../images/unity-scriptable-object/%E8%8E%B7%E5%8F%96SO%E6%95%B0%E6%8D%AE.png"></p><h1 id="序列化类"><a href="#序列化类" class="headerlink" title="序列化类"></a>序列化类</h1><p>除了在 SO 脚本中定义单一的字段，也可以使用类来组织数据结构。这个类是需要打上 Serializable 的标签。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">CreateAssetMenu(fileName = <span class="hljs-meta-string">&quot;SOConfig&quot;</span>, menuName = <span class="hljs-meta-string">&quot;SOConfig&quot;</span>, order = 0)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SOConfig</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> version;<br>    <span class="hljs-keyword">public</span> ConfigData configData;<br>&#125;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConfigData</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> description;<br>&#125;<br></code></pre></td></tr></table></figure><p>SO 数据文件的变化：</p><p><img src="/../images/unity-scriptable-object/SO%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB.png"></p><h1 id="简单的游戏配置"><a href="#简单的游戏配置" class="headerlink" title="简单的游戏配置"></a>简单的游戏配置</h1><p>对于一些简单的小游戏来说，使用 SO 做配置表，会比较简单快捷。</p><p>例如，一个商店的商品列表：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">CreateAssetMenu(fileName = <span class="hljs-meta-string">&quot;SOShop&quot;</span>, menuName = <span class="hljs-meta-string">&quot;SOShop&quot;</span>, order = 1)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SOShop</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;SOShopItem&gt; shopItems;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SOShopItem <span class="hljs-title">GetItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">return</span> shopItems.Find(x =&gt; x.id == id);<br>    &#125;<br>&#125;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SOShopItem</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> id;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> description;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> price;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置数据：</p><p><img src="/../images/unity-scriptable-object/%E7%AE%80%E5%8D%95%E6%B8%B8%E6%88%8F%E9%85%8D%E7%BD%AE.png"></p><p>使用配置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SODemo</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> SOConfig config;<br>    <span class="hljs-keyword">public</span> SOShop shop;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; shop.shopItems.Count; i++)<br>        &#123;<br>            SOShopItem item = shop.shopItems[i];<br>            Debug.Log(<span class="hljs-string">$&quot;name = <span class="hljs-subst">&#123;item.name&#125;</span> price = <span class="hljs-subst">&#123;item.price&#125;</span>&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/../images/unity-scriptable-object/%E9%81%8D%E5%8E%86%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8.png"></p><h1 id="动态修改配置"><a href="#动态修改配置" class="headerlink" title="动态修改配置"></a>动态修改配置</h1><p>SO 文件中填写的数据是可以在代码中赋值的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SODemo</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> SOConfig config;<br>    <span class="hljs-keyword">public</span> SOShop shop;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        config.version = <span class="hljs-string">&quot;1.0.1&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后 version 就变成了 1.0.1，并且这个修改是持久化的，新值覆盖了旧值。</p><p>如果只想在运行时修改，不想覆盖旧值，可以让 SO 创建实例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SODemo</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> SOConfig config;<br>    <span class="hljs-keyword">public</span> SOShop shop;<br><br>    <span class="hljs-keyword">public</span> SOConfig configInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        configInstance = ScriptableObject.CreateInstance&lt;SOConfig&gt;();<br>        configInstance.version = <span class="hljs-string">&quot;1.0.2&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后，可以看到有一个 SO 实例。</p><p><img src="/../images/unity-scriptable-object/SO%E5%AE%9E%E4%BE%8B.png"></p><p>双击查看实例数据，可以看到 SO 实例的 version 是 1.0.2，本地文件的 version 还是 1.0.1。</p><p><img src="/../images/unity-scriptable-object/SO%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 对象池</title>
    <link href="/2024/04/07/unity-objectpool/"/>
    <url>/2024/04/07/unity-objectpool/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 官方对象池的使用。</p><span id="more"></span><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>对象池是一个可以复用对象的容器。</p><p>当需要创建对象时，调用对象池的接口获得对象。</p><p>当需要销毁对象时，调用对象池的接口归还对象。</p><p>而对象池会判断池子里是否有可用的对象，如果有，直接取出一个对象返回，如果没有，就创建一个新的对象。</p><p>从对象池里取出的对象，使用完毕之后要放回对象池。</p><p>通过复用对象，减少了创建和销毁对象的次数，避免因频繁创建和销毁对象带来的性能问题。</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>下面来看看 Unity3D 官方提供的对象池类。</p><p>首先需要引用 <code>UnityEngine.Pool</code> 这个命名空间，然后使用 ObjectPool 这个类型定义一个成员字段，在 Start 中实例化，并提供一个用于创建对象的 OnCreate 函数，需要带有返回值，即创建好的新对象。</p><p>这里就简单地使用 <code>GameObject.CreatePrimitive</code> 创建一个 Cube。</p><p>在 Update 中，通过 <code>cubePool.Get()</code> 函数获得对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// 对象池命名空间</span><br><span class="hljs-keyword">using</span> UnityEngine.Pool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectPoolSample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 一个对象池</span><br>    <span class="hljs-keyword">public</span> ObjectPool&lt;GameObject&gt; cubePool;<br><br>    Vector3 pos;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 实例化对象池，必须提供一个创建对象的回调函数（带返回值）</span><br>        cubePool = <span class="hljs-keyword">new</span> ObjectPool&lt;GameObject&gt;(OnCreate);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 按下键盘 1 键</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))<br>        &#123;<br>            <span class="hljs-comment">// 从对象池中获得对象</span><br>            GameObject obj = cubePool.Get();<br>            obj.transform.position = pos;<br>            pos += Vector3.right;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 创建对象</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>新的对象<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function">GameObject <span class="hljs-title">OnCreate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 创建一个 Cube</span><br>        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归还对象"><a href="#归还对象" class="headerlink" title="归还对象"></a>归还对象</h1><p>目前只提供了创建对象的函数，还需要提供归还对象的函数。</p><p>添加一个 List，用于维护已创建的对象。</p><p>在实例化对象池时，第三个参数是归还对象时的回调函数 OnRelease，带有一个参数 GameObject obj，可以获取到被归还的对象，通过 <code>SetActive(false)</code> 把它隐藏。第二个参数暂时填 null。</p><p>然后在 Update 中添加一个按键 2 的逻辑，遍历 cubeList，把所有的对象都通过 <code>cubePool.Release</code> 归还，归还之前会调用 OnRelease 回调函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Pool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectPoolSample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">public</span> List&lt;GameObject&gt; cubeList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 实例化对象池时，添加一个新的回调函数 OnRelease</span><br>        cubePool = <span class="hljs-keyword">new</span> ObjectPool&lt;GameObject&gt;(OnCreate, <span class="hljs-literal">null</span>, OnRelease);<br>        cubeList = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))<br>        &#123;<br>            GameObject obj = cubePool.Get();<br>            <span class="hljs-comment">// ...</span><br>            cubeList.Add(obj);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; cubeList.Count; i++)<br>            &#123;<br>                cubePool.Release(cubeList[i]);<br>            &#125;<br>            cubeList.Clear();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRelease</span>(<span class="hljs-params">GameObject obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        obj.SetActive(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="再次获得对象"><a href="#再次获得对象" class="headerlink" title="再次获得对象"></a>再次获得对象</h1><p>因为在 OnRelease 函数中，隐藏了对象，此时对象池中存有的对象都是隐藏的，所以取出的对象都是隐藏的。</p><p>刚开始因为对象池内是空的，所以每次调用 <code>cubePool.Get()</code> 时，都会调用 OnCreate 函数。</p><p>但是当对象池不为空时，就不会再去调用 OnCreate 函数，而是调用另一个回调函数（也就是实例化对象池时，暂时填 null 的那个参数）。</p><p>所以还需要提供一个获得对象时的回调函数 OnGet，在这个函数中通过 <code>SetActive(true)</code> 把它显示出来。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Pool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectPoolSample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 实例化对象池时，添加一个新的回调函数 OnGet</span><br>        cubePool = <span class="hljs-keyword">new</span> ObjectPool&lt;GameObject&gt;(OnCreate, OnGet, OnRelease);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGet</span>(<span class="hljs-params">GameObject obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        obj.SetActive(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><p>可以看到，空池时，创建了三个 Cube，归还给对象池之后，再次获得三个 Cube，都是复用之前创建好的。</p><p><img src="/../images/unity-objectpool/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%8E%B7%E5%BE%97%E4%B8%8E%E5%BD%92%E8%BF%98.gif"></p><h1 id="销毁对象"><a href="#销毁对象" class="headerlink" title="销毁对象"></a>销毁对象</h1><p>当对象池最大容量已满，归还的对象是不会被存入对象池的，而是调用一个被销毁的回调函数。</p><p>主动调用 Clear 函数，也会为池内的所有对象都调用一次被销毁的回调函数。</p><p>此时可以提供一个 OnObjectDestroy 函数作为对象销毁时的回调函数（OnDestroy 是脚本的生命周期函数，需要换个名字避免冲突）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Pool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectPoolSample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 实例化对象池时，添加一个新的回调函数 OnObjectDestroy</span><br>        cubePool = <span class="hljs-keyword">new</span> ObjectPool&lt;GameObject&gt;(OnCreate, OnGet, OnRelease, OnObjectDestroy);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))<br>        &#123;<br>            cubePool.Clear();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnObjectDestroy</span>(<span class="hljs-params">GameObject obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">$&quot;销毁对象 <span class="hljs-subst">&#123;obj.name&#125;</span> pos = <span class="hljs-subst">&#123;obj.transform.position&#125;</span>&quot;</span>);<br>        Destroy(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><p>按键 1 创建三个 Cube，按键 2 归还所有 Cube，按键 3 销毁池内所有对象。</p><p><img src="/../images/unity-objectpool/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1.gif"></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// 对象池命名空间</span><br><span class="hljs-keyword">using</span> UnityEngine.Pool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectPoolSample</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 一个对象池</span><br>    <span class="hljs-keyword">public</span> ObjectPool&lt;GameObject&gt; cubePool;<br><br>    <span class="hljs-comment">// 维护对象的列表</span><br>    <span class="hljs-keyword">public</span> List&lt;GameObject&gt; cubeList;<br>    Vector3 pos;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 实例化对象池，必须提供一个创建对象的回调函数，其他回调函数都是可空的</span><br>        cubePool = <span class="hljs-keyword">new</span> ObjectPool&lt;GameObject&gt;(OnCreate, OnGet, OnRelease, OnObjectDestroy);<br>        cubeList = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 按键 1 获得对象</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))<br>        &#123;<br>            GameObject obj = cubePool.Get();<br>            obj.transform.position = pos;<br>            pos += Vector3.right;<br>            <span class="hljs-comment">// 添加到列表</span><br>            cubeList.Add(obj);<br>        &#125;<br>        <span class="hljs-comment">// 按键 2 归还所有对象</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; cubeList.Count; i++)<br>            &#123;<br>                cubePool.Release(cubeList[i]);<br>            &#125;<br>            cubeList.Clear();<br>        &#125;<br>        <span class="hljs-comment">// 按键 3 销毁池内的所有对象</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))<br>        &#123;<br>            cubePool.Clear();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 创建对象</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>新的对象<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function">GameObject <span class="hljs-title">OnCreate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 获得对象</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;obj&quot;&gt;</span>获得的对象<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGet</span>(<span class="hljs-params">GameObject obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        obj.SetActive(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 归还对象</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;obj&quot;&gt;</span>归还的对象<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRelease</span>(<span class="hljs-params">GameObject obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        obj.SetActive(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 销毁对象</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;obj&quot;&gt;</span>销毁的对象<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnObjectDestroy</span>(<span class="hljs-params">GameObject obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">$&quot;销毁对象 <span class="hljs-subst">&#123;obj.name&#125;</span> pos = <span class="hljs-subst">&#123;obj.transform.position&#125;</span>&quot;</span>);<br>        Destroy(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 基础 07 动画</title>
    <link href="/2024/03/31/unity-basic-7/"/>
    <url>/2024/03/31/unity-basic-7/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 基础系列（第七期 完结）</p><span id="more"></span><h1 id="动画控制器"><a href="#动画控制器" class="headerlink" title="动画控制器"></a>动画控制器</h1><p>首先，创建一个 Animator Controller 和一个 Animation 资源文件。</p><p><img src="/../images/unity-basic-7/%E5%88%9B%E5%BB%BA%E5%8A%A8%E7%94%BB.png"></p><p>双击 Animator Controller 文件，可以打开 Animator 窗口。</p><p>然后把 Animation 文件拖拽到 Animator 窗口，生成一个动画片段。</p><p><img src="/../images/unity-basic-7/%E5%88%9B%E5%BB%BA%E5%8A%A8%E7%94%BB%E7%89%87%E6%AE%B5.png"></p><p>给场景中的 Cube 添加一个 Animator 组件，并把资源文件拖拽赋值。</p><p><img src="/../images/unity-basic-7/%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E4%BB%B6.png"></p><p>通过顶部菜单栏打开 Animation 编辑窗口。</p><p><img src="/../images/unity-basic-7/%E5%8A%A8%E7%94%BB%E6%97%B6%E9%97%B4%E8%BD%B4%E7%AA%97%E5%8F%A3.png"></p><p>给 Cube 添加一个动画属性。</p><p><img src="/../images/unity-basic-7/%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7.png"></p><p>点击录制按钮，开始录制动画。</p><p><img src="/../images/unity-basic-7/%E5%BD%95%E5%88%B6%E5%8A%A8%E7%94%BB.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 基础 06 UGUI</title>
    <link href="/2024/03/24/unity-basic-6/"/>
    <url>/2024/03/24/unity-basic-6/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 基础系列（第六期）</p><span id="more"></span><h1 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h1><p>在 Hierarchy 面板右键，选择 UI -&gt; Canvas，创建一个画布。</p><p><img src="/../images/unity-basic-6/%E5%88%9B%E5%BB%BA%E7%94%BB%E5%B8%83.png"></p><p>可以看到画布默认带有一些组件：</p><ul><li>Canvas</li><li>Canvas Scaler</li><li>Graphic Raycaster</li></ul><p><img src="/../images/unity-basic-6/%E7%94%BB%E5%B8%83%E7%BB%84%E4%BB%B6.png"></p><p>Canvas 组件可以选择 Render Mode，有三种渲染模式。</p><ol><li>Overlay 模式会把画布渲染到最顶层，不会被其他元素遮挡。</li><li>Camera 模式需要指定一个相机，画布会被缩小到相机的尺寸范围内，可以通过设置 Plane Distance、Sorting Layer、Order in Layer 来控制画布的渲染层级。通常是推荐使用 Camera 模式。</li><li>World Space 模式是把画布当做 3D 世界物体来使用，可以自行调整画布的位置、旋转和缩放。</li></ol><p>Canvas Scaler 组件可以设置画布的分辨率。通常会设置成 Scale With Screen Size，指定一个合适的分辨率，当屏幕尺寸发生变化时，可以选择根据宽度还是高度进行适配。</p><p>Graphic Raycaster 组件是一个容易被忽略的组件，如果没有这个组件，画布是不会响应点击事件的。</p><h1 id="图片和文本"><a href="#图片和文本" class="headerlink" title="图片和文本"></a>图片和文本</h1><p>在 Hierarchy 面板右键，选择 UI -&gt; Image，创建一个图片。</p><p>旧版文本是在 Legacy 菜单中，选择 Text。</p><p>新版文本则是 Text-TextMeshPro。</p><p><img src="/../images/unity-basic-6/%E5%9B%BE%E7%89%87%E5%92%8C%E6%96%87%E6%9C%AC.png"></p><p>Image 组件可以在 Source Image 属性选择想要显示的图片，</p><p>Color 调整颜色和不透明度，</p><p>Raycast Target 控制是否要接收点击事件，</p><p>Maskable 控制是否被遮罩裁剪。</p><p><img src="/../images/unity-basic-6/%E5%9B%BE%E7%89%87%E7%BB%84%E4%BB%B6.png"></p><p>Text 组件主要填写 Text 属性的内容，</p><p>修改 Font 字体，Font Size 字体大小，Alignment 对齐方式。</p><p>同样也有 Raycast Target 和 Maskable 属性。</p><p><img src="/../images/unity-basic-6/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6.png"></p><p>效果图：</p><p><img src="/../images/unity-basic-6/%E5%9B%BE%E7%89%87%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C.png"></p><h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><p>在 Hierarchy 面板右键，选择 UI -&gt; Legacy -&gt; Button，创建一个按钮。</p><p><img src="/../images/unity-basic-6/%E6%8C%89%E9%92%AE.png"></p><p>Button 组件主要添加 OnClick 点击事件。</p><p>可以简单的，点击 OnClick 列表右下角的 + 号，添加一个事件，把标题文本拖拽到 Runtime Only 下面的选框中。</p><p>点击 Runtime Only 右侧的方法列表，例如选择 GameObject -&gt; SetActive，方法下面就会出现一个方框，勾选则代表 true，不勾选则代表 false。</p><p><img src="/../images/unity-basic-6/%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6.png"></p><p>除了直接在面板上添加点击事件，还可以通过代码添加。</p><p>例如，创建一个脚本 ButtonClick.cs，挂到按钮上，并拖拽一个文本给 text 字段。</p><p>在 Start 方法中，先获取按钮自身的 Button 组件，再通过 onClick.AddListener 方法添加另一个方法 HideText 作为点击事件，这个方法里把 text 字段引用的文本隐藏。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ButtonClick</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Text text;<br>    Button button;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        button = GetComponent&lt;Button&gt;();<br>        button.onClick.AddListener(HideText);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HideText</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        text.gameObject.SetActive(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/../images/unity-basic-6/%E9%9A%90%E8%97%8F%E6%96%87%E6%9C%AC.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 基础 05 场景加载</title>
    <link href="/2024/03/17/unity-basic-5/"/>
    <url>/2024/03/17/unity-basic-5/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 基础系列（第五期）</p><span id="more"></span><h1 id="场景配置"><a href="#场景配置" class="headerlink" title="场景配置"></a>场景配置</h1><p>首先，在资源文件夹里创建一个 LoadScene 场景，摆放一些物体，用来做初始场景。</p><p>然后创建一个 Stage 文件夹，并创建两个场景 Stage1、Stage2。</p><p>两个 Stage 场景也可以简单布置一下，方便区分。</p><p><img src="/../images/unity-basic-5/%E5%B8%83%E7%BD%AE%E5%9C%BA%E6%99%AF.png"></p><p>接着，打开 Build Settings，把需要加载的场景添加到配置中。</p><p><img src="/../images/unity-basic-5/%E5%9C%BA%E6%99%AF%E6%89%93%E5%8C%85%E8%AE%BE%E7%BD%AE.png"></p><h1 id="切换场景"><a href="#切换场景" class="headerlink" title="切换场景"></a>切换场景</h1><p>创建一个 SceneLoader 脚本，并在 LoadScene 场景中创建一个空物体，挂载这个脚本。</p><p>这里为了方便调用加载场景的方法，简单使用了单例模式，在 Awake 初始化时，把当前脚本实例保存到 instance 变量里，并且设置为 DontDestroyOnLoad，保证这个对象不会因为场景切换而被销毁，其他对象通过 Instance 属性获取到单例。</p><p>当前脚本提供一个 LoadScene 方法，传入一个场景名称就可以直接切换场景。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SceneLoader</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 单例模式</span><br>    <span class="hljs-keyword">static</span> SceneLoader instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SceneLoader Instance<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> instance; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Destroy(gameObject);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            instance = <span class="hljs-keyword">this</span>;<br>            DontDestroyOnLoad(gameObject);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadScene</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sceneName</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        SceneManager.LoadScene(sceneName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着再创建一个脚本 ChangeScene，挂载到场景中的 3D 物体上，并填写目标场景的名称。</p><p>OnMouseDown 方法会在物体被鼠标点击时调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChangeScene</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> sceneName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        SceneLoader.Instance.LoadScene(sceneName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/unity-basic-5/%E7%9B%AE%E6%A0%87%E5%9C%BA%E6%99%AF.png"></p><p><img src="/../images/unity-basic-5/%E5%9B%9E%E5%88%B0%E4%B8%BB%E5%9C%BA%E6%99%AF.png"></p><p>场景切换效果：</p><p><img src="/../images/unity-basic-5/%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C.gif"></p><h1 id="场景叠加"><a href="#场景叠加" class="headerlink" title="场景叠加"></a>场景叠加</h1><p>目前场景加载是卸载掉原来的场景，加载新的场景，DontDestroyOnLoad 场景一直存在。</p><p>并且场景加载是同步的，如果新的场景包含的物体资源太多，加载时间稍慢的话，就会感觉到卡顿。</p><p>场景是可以叠加的，也就是同时加载了多个场景，也有异步加载的方式。</p><p>下面添加两个方法，用来加载或卸载场景。因为是异步加载，需要使用协程，场景加载完成后可以执行其他操作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SceneLoader</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 当前加载的场景</span><br>    Scene currentScene;<br>    <br>    <span class="hljs-comment">// 加载场景（异步加载，叠加模式）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadSceneAdditive</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sceneName</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        StartCoroutine(LoadSceneAsync(sceneName));<br>    &#125;<br><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadSceneAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sceneName</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        AsyncOperation operation = SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Additive);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> operation;<br>        <span class="hljs-comment">// 加载完成后，保存当前加载的场景</span><br>        currentScene = SceneManager.GetSceneByName(sceneName);<br>    &#125;<br><br>    <span class="hljs-comment">// 卸载当前已加载的场景</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UnloadCurrentScene</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 判断是否加载过当前场景</span><br>        <span class="hljs-keyword">if</span> (!currentScene.IsValid()) <span class="hljs-keyword">return</span>;<br>        StartCoroutine(UnloadCurrentSceneAsync());<br>    &#125;<br><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">UnloadCurrentSceneAsync</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        AsyncOperation operation = SceneManager.UnloadSceneAsync(currentScene);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> operation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改一下 ChangeScene 脚本调用的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChangeScene</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> sceneName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 先卸载当前加载的场景</span><br>        SceneLoader.Instance.UnloadCurrentScene();<br>        <br>        <span class="hljs-comment">// 加载新的场景（叠加模式）</span><br>        SceneLoader.Instance.LoadSceneAdditive(sceneName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Stage 场景也需要修改一下，隐藏掉相机和灯光，因为主场景已经有了，多个相机和灯光会影响视觉效果。</p><p><img src="/../images/unity-basic-5/%E4%BF%AE%E6%94%B9%E5%9C%BA%E6%99%AF.png"></p><p>场景叠加效果：</p><p><img src="/../images/unity-basic-5/%E5%9C%BA%E6%99%AF%E5%8F%A0%E5%8A%A0.gif"></p><p><img src="/../images/unity-basic-5/%E5%9C%BA%E6%99%AF%E5%8F%A0%E5%8A%A02.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 基础 04 物理效果</title>
    <link href="/2024/03/10/unity-basic-4/"/>
    <url>/2024/03/10/unity-basic-4/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 基础系列（第四期）</p><span id="more"></span><h1 id="刚体"><a href="#刚体" class="headerlink" title="刚体"></a>刚体</h1><p>在场景中创建一个 Cube，然后为它添加一个 Rigidbody 组件。</p><p>此时，Cube 就有了重力，如果运行游戏，Cube 会模拟自由落体，往下掉落。</p><p><img src="/../images/unity-basic-4/%E6%B7%BB%E5%8A%A0%E5%88%9A%E4%BD%93.png"></p><p>可以简单布置一下场景，在 Cube 下面放置一个 Plane，这样 Cube 就会站立在平面上。</p><p>当然，也可以修改 Rigidbody 组件的参数，取消勾选 Use Gravity 或者勾选 Is Kinematic，也会取消重力效果。</p><p><img src="/../images/unity-basic-4/%E5%B8%83%E7%BD%AE%E5%9C%BA%E6%99%AF.png"></p><p>刚体组件也可以让物体移动，只需要修改刚体的 velocity 属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RigidbodyMove</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed = <span class="hljs-number">5f</span>;   <span class="hljs-comment">// 移动速度</span><br>    <span class="hljs-keyword">public</span> Vector3 direction;  <span class="hljs-comment">// 移动方向</span><br>    <span class="hljs-keyword">public</span> Rigidbody rb;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        rb = GetComponent&lt;Rigidbody&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 水平偏移量</span><br>        <span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br>        <span class="hljs-comment">// 垂直偏移量</span><br>        <span class="hljs-built_in">float</span> v = Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>);<br>        <span class="hljs-comment">// 修改方向向量</span><br>        direction.x = h;<br>        direction.z = v;<br>        <span class="hljs-comment">// 设置刚体速度</span><br>        rb.velocity = speed * direction;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/../images/unity-basic-4/%E5%88%9A%E4%BD%93%E7%A7%BB%E5%8A%A8.gif"></p><h1 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h1><p>在创建 Cube 时，默认会挂载一个碰撞体组件。</p><p>勾选 Is Trigger 会取消碰撞效果，只做触发器。</p><p>Center 和 Size 用来控制碰撞体的中心位置和大小。</p><p><img src="/../images/unity-basic-4/%E7%A2%B0%E6%92%9E%E4%BD%93%E5%B1%9E%E6%80%A7.png"></p><p>如果要让两个物体碰撞，监听发生碰撞的时刻，需要其中一个物体带有刚体组件，另一个物体可以没有刚体。</p><p>当然，两个物体都要有碰撞体。</p><p>如果没有刚体的碰撞体，勾选了 Is Trigger，那么带有刚体的物体监听的碰撞回调函数是 OnTrigger 系列的函数。</p><p>如果没有刚体的碰撞体，没有勾选 Is Trigger，那么带有刚体的物体监听的碰撞回调函数是 OnCollision 系列的函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RigidbodyMove</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 进入触发</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;触发 &quot;</span> + other.name);<br>    &#125;<br><br>    <span class="hljs-comment">// 进入碰撞</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision other</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;碰撞 &quot;</span> + other.collider.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在场景中添加一个球体，并且把球的碰撞体设置为 Trigger。</p><p>可以看到 Console 窗口打印的信息。</p><p>因为 Plane 也带有碰撞体，并且不是 Trigger，所以会打印 碰撞 Plane。</p><p>而球体是 Trigger，所以会打印 触发 Sphere。</p><p><img src="/../images/unity-basic-4/%E8%A7%A6%E5%8F%91.png"></p><p>类似的碰撞回调函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 进入触发器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 停留触发器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerStay</span>(<span class="hljs-params">Collider other</span>)</span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 退出触发器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerExit</span>(<span class="hljs-params">Collider other</span>)</span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 进入碰撞体</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision other</span>)</span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 停留碰撞体</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionStay</span>(<span class="hljs-params">Collision other</span>)</span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 退出碰撞体</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionExit</span>(<span class="hljs-params">Collision other</span>)</span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 基础 03 预制体</title>
    <link href="/2024/03/03/unity-basic-3/"/>
    <url>/2024/03/03/unity-basic-3/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 基础系列（第三期）</p><span id="more"></span><h1 id="创建预制体"><a href="#创建预制体" class="headerlink" title="创建预制体"></a>创建预制体</h1><p>创建预制体的方法很简单，直接把场景中的游戏物体，拖拽到 Assets 文件夹里，就会生成一个预制体资源了。</p><p><img src="/../images/unity-basic-3/%E5%88%9B%E5%BB%BA%E9%A2%84%E5%88%B6%E4%BD%93.png"></p><p>除了拖拽的方式，也可以在 Create 菜单中找到创建预制体的按钮，此时会创建一个空的预制体。</p><p><img src="/../images/unity-basic-3/%E5%88%9B%E5%BB%BA%E9%A2%84%E5%88%B6%E4%BD%932.png"></p><h1 id="修改预制体"><a href="#修改预制体" class="headerlink" title="修改预制体"></a>修改预制体</h1><p>双击 Assets 文件夹里的预制体资源，可以进入编辑模式。</p><p>在编辑模式下，给预制体增加一个球模型，点击 Save 按钮保存。</p><p>保存之后，点击 Save 按钮旁边的 &lt; 按钮，退出编辑模式，回到场景。</p><p><img src="/../images/unity-basic-3/%E4%BF%AE%E6%94%B9%E9%A2%84%E5%88%B6%E4%BD%93.png"></p><p>回到场景之后，发现场景中的游戏物体都会随之修改。</p><p>同时，也可以把预制体从 Assets 文件夹里再次拖拽到场景中，会生成新的一模一样的游戏物体。</p><p>后续对预制体的修改，都会同时改变场景中引用同一个预制体资源的所有游戏物体。</p><p><img src="/../images/unity-basic-3/%E6%8B%96%E6%8B%BD%E6%96%B0%E7%9A%84%E9%A2%84%E5%88%B6%E4%BD%93.png"></p><p>除了在 Assets 文件夹中双击预制体进行编辑的方式外，还可以直接在场景中，对游戏物体进行修改，然后应用到预制体上。</p><p>例如，在其中一个游戏物体中，再次添加一个小球，点击 Overrides 按钮，可以看到有哪些修改。</p><p>如果直接点击 Apply All，就会把所有修改都覆盖到预制体。</p><p>也可以单独点击其中某个修改，点击 Apply 按钮，再次点击 Apply to Prefab ‘Cube’ 按钮，就可以把单条修改覆盖到预制体。</p><p><img src="/../images/unity-basic-3/%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%BF%AE%E6%94%B9%E9%A2%84%E5%88%B6%E4%BD%93.png"></p><p>应用覆盖之后，场景中的游戏物体和资源里的预制体都会发生改变。</p><p><img src="/../images/unity-basic-3/%E8%A6%86%E7%9B%96%E9%A2%84%E5%88%B6%E4%BD%93.png"></p><h1 id="实例化预制体"><a href="#实例化预制体" class="headerlink" title="实例化预制体"></a>实例化预制体</h1><p>除了直接从 Assets 文件夹里拖拽预制体到场景中，进行游戏物体的生成外，还可以通过代码的方式实例化预制体。</p><p>创建一个脚本 CreateGameObjectByPrefab.cs，代码如下。</p><p>其中 cubePrefab 是要实例化的预制体资源，</p><p>pos 是生成的位置，</p><p>step 是每次修改生成位置的步长。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CreateGameObjectByPrefab</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject cubePrefab;<br>    <span class="hljs-keyword">public</span> Vector3 pos;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> step = <span class="hljs-number">1f</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 按下键盘 G 键</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.G))<br>        &#123;<br>            Generate();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Generate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GameObject obj = Instantiate(cubePrefab);<br>        obj.transform.position = pos;<br>        pos.x += step;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在场景中创建一个空物体，并把脚本拖拽到空物体上，再把 Cube 预制体拖拽到 Cube Prefab 属性上，设置好 pos 和 step 的参数。</p><p><img src="/../images/unity-basic-3/%E6%8B%96%E6%8B%BD%E9%A2%84%E5%88%B6%E4%BD%93%E5%BC%95%E7%94%A8.png"></p><p>运行游戏，按下键盘 G 键，可以看到场景中不断地生成新的游戏物体。</p><p><img src="/../images/unity-basic-3/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 基础 02 控制移动</title>
    <link href="/2024/02/25/unity-basic-2/"/>
    <url>/2024/02/25/unity-basic-2/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 基础系列（第二期）</p><span id="more"></span><h1 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h1><p>首先，新建一个场景，创建一个 Cube。</p><p>在 Assets 文件夹中创建一个 Scripts 文件夹，用来存放代码文件。</p><p>然后创建一个 PlayerController.cs 代码文件，拖拽挂载到 Cube 身上。</p><p><img src="/../images/unity-basic-2/%E5%88%9B%E5%BB%BA%E8%84%9A%E6%9C%AC.png"></p><h1 id="物体移动"><a href="#物体移动" class="headerlink" title="物体移动"></a>物体移动</h1><p>打开 PlayerController.cs 编辑代码。</p><p>添加 speed 和 direction 两个变量，在 Update 方法中，通过 Input.GetAxis 获取键盘 WSAD 或 方向键 的输入，修改移动方向，并计算改变 transform.position 的数值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed = <span class="hljs-number">5f</span>;   <span class="hljs-comment">// 移动速度</span><br>    <span class="hljs-keyword">public</span> Vector3 direction;  <span class="hljs-comment">// 移动方向</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 水平偏移量</span><br>        <span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br>        <span class="hljs-comment">// 垂直偏移量</span><br>        <span class="hljs-built_in">float</span> v = Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>);<br>        <span class="hljs-comment">// 修改方向向量</span><br>        direction.x = h;<br>        direction.y = v;<br>        <span class="hljs-comment">// 计算移动距离并修改物体位置</span><br>        transform.position += speed * Time.deltaTime * direction;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>移动效果：</p><p><img src="/../images/unity-basic-2/%E7%A7%BB%E5%8A%A8%E6%95%88%E6%9E%9C.gif"></p><blockquote><p>注意到，这里计算移动距离时，乘了一个 Time.deltaTime 变量，可以尝试去掉这个变量，看看效果。</p></blockquote><p>Time.deltaTime 表示一帧的间隔时间，根据设备配置和运行状况，这个变量的数值会不断变化。</p><p>假设运行帧率是 30 FPS，Time.deltaTime 的数值是 1/30。</p><p>假设运行帧率是 60 FPS，Time.deltaTime 的数值是 1/60。</p><p>Update 方法是每帧调用一次，假设 Cube 每帧移动的距离为 5，在每秒 30 帧的情况下，每秒移动的距离是 150。</p><p>而在每秒 60 帧的情况下，每秒移动的距离是 300。</p><p>也就是说，不同帧率的效果表现是不同的。</p><p>为了解决这个问题，乘上一个 Time.deltaTime，使得每秒移动的距离都变为常量 5，得到相同的表现效果。</p><h1 id="物体旋转"><a href="#物体旋转" class="headerlink" title="物体旋转"></a>物体旋转</h1><p>除了通过 Input.GetAxis 获取水平和垂直方向上的偏移量，还可以通过 Input.GetKey 获取键盘的其他按键。</p><p>例如，使用枚举 KeyCode.Q 获取键盘 Q 键，当 Q 键被持续按下时，持续修改 Y 轴 旋转角度，并使用 Quaternion.Euler 方法进行转换，使物体的旋转属性保持在一个正常的范围内，然后赋值给 transform.rotation。</p><p>反向同理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> rotateSpeed = <span class="hljs-number">100f</span>;   <span class="hljs-comment">// 旋转速度</span><br>    <span class="hljs-keyword">public</span> Vector3 rotation;           <span class="hljs-comment">// 旋转角度</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 按住 Q 键</span><br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.Q))<br>        &#123;<br>            <span class="hljs-comment">// 持续修改 Y 轴 旋转角度（顺时针）</span><br>            rotation.y += rotateSpeed * Time.deltaTime;<br>            transform.rotation = Quaternion.Euler(rotation);<br>        &#125;<br>        <span class="hljs-comment">// 按住 E 键</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.E))<br>        &#123;<br>            <span class="hljs-comment">// 持续修改 Y 轴 旋转角度（逆时针）</span><br>            rotation.y -= rotateSpeed * Time.deltaTime;<br>            transform.rotation = Quaternion.Euler(rotation);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>旋转效果：</p><p><img src="/../images/unity-basic-2/%E6%97%8B%E8%BD%AC%E6%95%88%E6%9E%9C.gif"></p><h1 id="物体缩放"><a href="#物体缩放" class="headerlink" title="物体缩放"></a>物体缩放</h1><p>了解了键盘按键，可以再看看鼠标按键。</p><p>可以通过 Input.GetMouseButtonDown 方法获取鼠标按键按下的状态，传入 0 则是鼠标左键，传入 1 则是鼠标右键。</p><p>这里修改了 transform.localScale，让 Cube 放大或变回原样。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> bigger = <span class="hljs-number">2f</span>;    <span class="hljs-comment">// 缩放系数（放大）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> normal = <span class="hljs-number">1f</span>;    <span class="hljs-comment">// 缩放系数（正常）</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 按下鼠标左键</span><br>        <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">0</span>))<br>        &#123;<br>            transform.localScale = Vector3.one * bigger;<br>        &#125;<br>        <span class="hljs-comment">// 按下鼠标右键</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">1</span>))<br>        &#123;<br>            transform.localScale = Vector3.one * normal;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缩放效果：</p><p><img src="/../images/unity-basic-2/%E7%BC%A9%E6%94%BE%E6%95%88%E6%9E%9C.gif"></p><h1 id="按键总结"><a href="#按键总结" class="headerlink" title="按键总结"></a>按键总结</h1><p>下面列举了一系列按键输入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 键盘</span><br>Input.GetKey(KeyCode.W)           <span class="hljs-comment">// 按住 W 键持续返回 true, 松开后返回 false</span><br>Input.GetKeyDown(KeyCode.W)       <span class="hljs-comment">// 按下 W 键返回 true，按住也只会返回 false</span><br>Input.GetKeyUp(KeyCode.W)         <span class="hljs-comment">// 抬起 W 键返回 true</span><br><br><span class="hljs-comment">// 注：这里的 Jump 在 Input Manager 里默认是空格键</span><br>Input.GetButton(<span class="hljs-string">&quot;Jump&quot;</span>)           <span class="hljs-comment">// 按住自定义的键持续返回 true, 松开后返回 false</span><br>Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)       <span class="hljs-comment">// 按下自定义的键返回 true，按住也只会返回 false</span><br>Input.GetButtonUp(<span class="hljs-string">&quot;Jump&quot;</span>)         <span class="hljs-comment">// 抬起自定义的键返回 true</span><br><br>Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>)       <span class="hljs-comment">// AD 或左右方向键的偏移量 (从 0 到 1 变化，或从 0 到 -1 变化)</span><br>Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>)         <span class="hljs-comment">// WS 或上下方向键的偏移量 (从 0 到 1 变化，或从 0 到 -1 变化)</span><br>    <br>Input.GetAxisRaw(<span class="hljs-string">&quot;Horizontal&quot;</span>)    <span class="hljs-comment">// AD 或左右方向键的偏移量 (-1 0 1)</span><br>Input.GetAxisRaw(<span class="hljs-string">&quot;Vertical&quot;</span>)      <span class="hljs-comment">// WS 或上下方向键的偏移量 (-1 0 1)</span><br><br><br><span class="hljs-comment">// 鼠标 0: 左键  1: 右键  2: 中键</span><br>Input.GetMouseButton(<span class="hljs-number">0</span>)       <span class="hljs-comment">// 按住鼠标左键</span><br>Input.GetMouseButtonDown(<span class="hljs-number">1</span>)   <span class="hljs-comment">// 按下鼠标右键</span><br>Input.GetMouseButtonUp(<span class="hljs-number">2</span>)     <span class="hljs-comment">// 抬起鼠标中键</span><br><br>Input.GetAxis(<span class="hljs-string">&quot;Mouse X&quot;</span>)      <span class="hljs-comment">// 鼠标水平方向移动的偏移量</span><br>Input.GetAxis(<span class="hljs-string">&quot;Mouse Y&quot;</span>)      <span class="hljs-comment">// 鼠标垂直方向移动的偏移量</span><br></code></pre></td></tr></table></figure><p>Input Manager 可以自定义按键名称和对应的键盘按键。</p><p><img src="/../images/unity-basic-2/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 基础 01 安装入门</title>
    <link href="/2024/02/18/unity-basic-1/"/>
    <url>/2024/02/18/unity-basic-1/</url>
    
    <content type="html"><![CDATA[<p>Unity3D 基础系列（第一期）</p><span id="more"></span><h1 id="安装编辑器"><a href="#安装编辑器" class="headerlink" title="安装编辑器"></a>安装编辑器</h1><p>Unity 中文官网：<a href="https://unity.cn/releases">https://unity.cn/releases</a></p><p>在官网找到想要安装的版本，点击<kbd>从Unity Hub下载</kbd></p><p><img src="/../images/unity-basic-1/%E5%AE%89%E8%A3%85hub.png"></p><p>如果电脑上没有安装 hub，就需要先安装好 hub，再点击上图的按钮，hub 会弹窗安装对应的编辑器版本。</p><p>如果需要打包到安卓手机，则需要安装 Android Build Support 模块。需要其他平台就勾选对应的模块。</p><p>如果只需要打包到 Windows 平台，可以不用勾选模块，默认是可以打包 Windows 程序的。</p><p><img src="/../images/unity-basic-1/%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97.png"></p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>安装完成之后，在 hub 界面点击右上角的<kbd>New project</kbd>创建项目。</p><p><img src="/../images/unity-basic-1/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"></p><p>默认是 3D 项目模板，修改一下 Project name（项目名称）和 Location（本地文件夹存放位置），点击右下角的<kbd>Create project</kbd>按钮开始创建新项目。</p><p><img src="/../images/unity-basic-1/%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF.png"></p><p>项目创建完成后，可以在右上角的下拉列表中，选择一个自己喜欢的窗口布局。</p><p><img src="/../images/unity-basic-1/%E4%BF%AE%E6%94%B9%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80.png"></p><p>右键点击窗口的标签栏，还可以选择单列或双列的布局。</p><p><img src="/../images/unity-basic-1/%E4%BF%AE%E6%94%B9%E5%B0%8F%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80.png"></p><h1 id="认识窗口"><a href="#认识窗口" class="headerlink" title="认识窗口"></a>认识窗口</h1><p>主要的窗口有</p><ul><li>Scene（编辑场景）</li><li>Game（运行游戏）</li><li>Inspector（组件属性）</li><li>Hierarchy（物体层级）</li><li>Project（项目资源）</li><li>Console（调试输出）</li></ul><p>这六个基本的窗口可以在 Window 菜单里面找到并打开。</p><p><img src="/../images/unity-basic-1/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E7%AA%97%E5%8F%A3.png"></p><p>通常会在 Hierarchy 窗口空白处，右键单击，可以创建一个 Cube 立方体或者其他物体。</p><p><img src="/../images/unity-basic-1/%E5%88%9B%E5%BB%BA%E7%AB%8B%E6%96%B9%E4%BD%93.png"></p><p>Project 窗口，则是右键单击 Assets 文件夹，展开 Create 菜单，可以看到很多选项，用于创建 unity 内置资源。</p><ul><li>Folder（创建文件夹）</li><li>C# Script（创建 C# 脚本）</li><li>Scene（创建场景）</li><li>Material（创建材质）</li><li>Animator Controller（创建动画控制器）</li><li>Animation（创建动画片段）</li></ul><p><img src="/../images/unity-basic-1/%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90.png"></p><p>需要导入外部资源时，也可以直接将资源拖到 Assets 文件夹下。</p><p><img src="/../images/unity-basic-1/%E5%AF%BC%E5%85%A5%E5%9B%BE%E7%89%87.png"></p><p>然后选中导入后的图片，可以在 Inspector 窗口看到图片资源的一些属性设置，通常会把图片的 Texture Type 改成 Sprite 类型，用于 2D Sprite 和 UI 图片，最后点击下方的 Apply 按钮确认修改。</p><p><img src="/../images/unity-basic-1/%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E7%B1%BB%E5%9E%8B.png"></p><p>在 Hierarchy 窗口空白处，右键单击，可以创建一个 Image 图片，修改它的 Source Image 属性，可以点击右侧的小圆圈按钮，选择刚刚导入的图片，或者直接把图片拖拽到 Source Image 处。</p><p>点击 Set Native Size 按钮，可以让图片自动设置成图片源本身的宽度和高度，具体数值也可以在右上角的 Rect Transform 组件属性里调整。</p><p>此时就可以在 Scene 窗口看到导入的图片了。</p><p>Scene 窗口有个 2D 按钮，可以切换成 2D 平面视角。</p><p><img src="/../images/unity-basic-1/UI%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87.png"></p><p>点击顶部的播放按钮，可以运行游戏，查看游戏运行效果。此时会自动跳转到 Game 窗口。</p><p>Game 窗口可以设置游戏运行的屏幕分辨率尺寸，点击下拉菜单最下方的 + 号，可以添加自定义的分辨率尺寸。</p><p><img src="/../images/unity-basic-1/%E8%BF%90%E8%A1%8C%E6%B8%B8%E6%88%8F.png"></p><p>每个窗口的位置也是可以自行调整的，例如，点击 Console 窗口的标签，按住鼠标左键，拖动到 Project 标签旁边，就可以让这两个窗口共用一个区域，点击窗口标签的时候会切换窗口显示。</p><p>Console 窗口是运行游戏时，显示代码脚本输出的一些调试信息，目前还没有写代码输出信息，所以这个窗口就是空白的。</p><p><img src="/../images/unity-basic-1/%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A0%87%E7%AD%BE.png"></p><h1 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h1><p>在 Window 菜单，找到 Package Manager，打开插件包管理窗口。</p><p>Packages: Unity Registry 表示有经过 unity 注册认证过的插件，此处可以选择其他类型的筛选条件。</p><p>右上角的搜索框可以快速搜索到需要的插件，点击右下角的 Install 按钮安装插件。</p><p><img src="/../images/unity-basic-1/%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86.png"></p><p>Packages: In Project 可以查看当前项目里已安装的所有插件，可以对选中的插件进行升级或者移除。</p><p><img src="/../images/unity-basic-1/%E5%8D%87%E7%BA%A7%E6%88%96%E5%88%A0%E9%99%A4%E6%8F%92%E4%BB%B6.png"></p><h1 id="打包项目"><a href="#打包项目" class="headerlink" title="打包项目"></a>打包项目</h1><p>点击菜单栏的 File -&gt; Build Settings，点击 Add Open Scenes 把当前打开的场景添加到打包列表中，也可以自行从 Assets 文件夹中拖拽需要打包的场景，有勾选的场景会被打包，去掉勾选就不会被打包。</p><p>Platform 可以选择要打包的目标平台，默认是 Windows，如果需要打包到其他平台，就需要安装对应的模块。</p><p>最后点击 Build 按钮，选择一个存放的位置，进行打包。</p><p><img src="/../images/unity-basic-1/%E6%89%93%E5%8C%85%E8%AE%BE%E7%BD%AE.png"></p><p>Player Settings 可以修改一些打包参数，例如公司名称、项目名称、版本号、图标等等。</p><p><img src="/../images/unity-basic-1/%E6%89%93%E5%8C%85%E5%8F%82%E6%95%B0.png"></p><p>打包完成后，如果是 Windows 平台，可以双击 .exe 文件运行游戏。</p><p>打开游戏后，默认是全屏的，没有退出游戏按钮，可以直接按 Alt + F4 快捷键关闭游戏。</p><p><img src="/../images/unity-basic-1/%E8%BF%90%E8%A1%8C%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E6%B8%B8%E6%88%8F.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 基础语法 07 抽象接口</title>
    <link href="/2024/02/12/csharp-basic-7/"/>
    <url>/2024/02/12/csharp-basic-7/</url>
    
    <content type="html"><![CDATA[<p>简单复习一下 C# 基础语法（第七期 完结）。</p><span id="more"></span><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类是未完全实现逻辑的类，专门作为基类来使用，将具体逻辑推迟到合适的派生类去实现。</p><p>下面是一个具体类 FlyObject，包含一个虚方法 Fly，它可以有方法体，此时方法体内是空的，没有需要实现的逻辑。</p><p>由它衍生出两个具体类，Bird 和 Plane，它们都重写了 Fly 方法，并且加上了具体逻辑。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FlyObject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> : <span class="hljs-title">FlyObject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;小鸟在飞行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Plane</span> : <span class="hljs-title">FlyObject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;飞机在飞行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用时</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        FlyObject bird = <span class="hljs-keyword">new</span> Bird();<br>        bird.Fly();<br>        <span class="hljs-comment">// 小鸟在飞行</span><br><br>        FlyObject plane = <span class="hljs-keyword">new</span> Plane();<br>        plane.Fly();<br>        <span class="hljs-comment">// 飞机在飞行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于基类 FlyObject 的 Fly 方法并没有具体实现逻辑，只是一个空的方法，此时可以将基类的 Fly 方法改成一个抽象方法，并去掉方法体。</p><p>因为包含了抽象方法，FlyObject 也需要加上 abstract 变成一个抽象类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FlyObject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类不能被实例化，需要有派生类继承它，通过派生类实例化。</p><p>继承了抽象类的派生类，必须通过重写，实现抽象方法。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是完全未实现逻辑的“类”，只有方法成员。</p><p>和抽象类一样，接口也不能被实例化，需要有其他类去实现接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFlyObject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> : <span class="hljs-title">IFlyObject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;小鸟在飞行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Plane</span> : <span class="hljs-title">IFlyObject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;飞机在飞行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口约定以 I 为开头进行命名，接口内定义的方法成员必须是 public 的，可以省略不写。</p><p>实现接口的类，必须包含接口内定义的所有方法成员，并且不需要写 override。</p><p>使用时</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        IFlyObject bird = <span class="hljs-keyword">new</span> Bird();<br>        bird.Fly();<br><br>        IFlyObject plane = <span class="hljs-keyword">new</span> Plane();<br>        plane.Fly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和抽象类不同的是，抽象类只能继承一个，接口可以同时实现多个。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 基础语法 06 委托事件</title>
    <link href="/2024/02/04/csharp-basic-6/"/>
    <url>/2024/02/04/csharp-basic-6/</url>
    
    <content type="html"><![CDATA[<p>简单复习一下 C# 基础语法（第六期）。</p><span id="more"></span><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托是一个类，可以被实例化，包装一系列的方法，相当于一个方法的容器，可以作为参数传入其他方法。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>方法的参数列表内，有一个委托参数，方法体会调用这个委托参数。</p><p>而委托参数包装的是什么样的方法，则由外部传入的方法决定。</p><p>相当于一个填空题，借助外部的方法产生结果。</p><p>模板委托方法通常在代码的中间部分，有返回值。</p><p>定义一个 Person 类，包含人物的名字和正在思考的内容。</p><p>同时，定义一个 Answer 类，用来包装人物答题的内容。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> person;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> result;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> thinking</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        person = name;<br>        result = thinking;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Answer <span class="hljs-title">Think</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Answer answer = <span class="hljs-keyword">new</span> Answer();<br>        answer.person = person;<br>        answer.result = result;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Answer</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> person;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义一个 Exam 类，输出答题人和答案。</p><p>其中，方法的参数是一个委托，Func 类是 C# 内部定义好的一个委托类，它可以有返回值，尖括号 &lt; &gt; 内填入返回值的类型。</p><p>在方法内部调用委托，得到 Answer 类型的返回值，把内容打印输出。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnswerQuestion</span>(<span class="hljs-params">Func&lt;Answer&gt; solution</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Answer answer = solution.Invoke();<br>        Console.WriteLine(<span class="hljs-string">$&quot;答题人：<span class="hljs-subst">&#123;answer.person&#125;</span> 答案：<span class="hljs-subst">&#123;answer.result&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际使用时，可以定义 Func 变量，new 一个委托实例，将一个实例的方法作为参数传入。</p><p>然后把委托变量传给 AnswerQuestion 方法，同一个方法，可以接收不同的委托变量，实现功能的复用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Exam exam = <span class="hljs-keyword">new</span> Exam();<br>        Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;鸡排&quot;</span>);<br>        Person person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-string">&quot;奶茶&quot;</span>);<br><br>        Func&lt;Answer&gt; func1 = <span class="hljs-keyword">new</span> Func&lt;Answer&gt;(person1.Think);<br>        Func&lt;Answer&gt; func2 = <span class="hljs-keyword">new</span> Func&lt;Answer&gt;(person2.Think);<br><br>        exam.AnswerQuestion(func1);<br>        exam.AnswerQuestion(func2);<br>        <br>        <span class="hljs-comment">// 答题人：小明 答案：鸡排</span><br>        <span class="hljs-comment">// 答题人：小红 答案：奶茶</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>同样，方法的参数列表内，有一个委托参数。</p><p>在执行完一系列代码之后，调用外部方法进行回调。</p><p>回调委托方法通常在代码的末尾部分，无返回值。</p><p>继续上面的例子，添加一个 Logger 类，用于答题后的信息提示。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> message;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Logger</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展 AnswerQuestion 的参数列表，并在打印答题结果之后进行回调。</p><p>Action 类也是 C# 内部定义好的一个委托类，无返回值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnswerQuestion</span>(<span class="hljs-params">Func&lt;Answer&gt; solution, Action callback</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Answer answer = solution.Invoke();<br>        Console.WriteLine(<span class="hljs-string">$&quot;答题人：<span class="hljs-subst">&#123;answer.person&#125;</span> 答案：<span class="hljs-subst">&#123;answer.result&#125;</span>&quot;</span>);<br>        callback.Invoke();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化 Logger 类，填入信息提示。</p><p>可以定义 Action 变量并实例化，传入 Logger 类的 Log 方法。</p><p>然后把 action 变量作为参数，作为回调方法传入 AnswerQuestion 方法中。</p><p>现在每次打印答题结果之后，都会有答题成功的信息提示。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Exam exam = <span class="hljs-keyword">new</span> Exam();<br>        Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;鸡排&quot;</span>);<br>        Person person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-string">&quot;奶茶&quot;</span>);<br><br>        Func&lt;Answer&gt; func1 = <span class="hljs-keyword">new</span> Func&lt;Answer&gt;(person1.Think);<br>        Func&lt;Answer&gt; func2 = <span class="hljs-keyword">new</span> Func&lt;Answer&gt;(person2.Think);<br><br>        Logger logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">&quot;答题成功&quot;</span>);<br>        Action action = <span class="hljs-keyword">new</span> Action(logger.Log);<br><br>        exam.AnswerQuestion(func1, action);<br>        exam.AnswerQuestion(func2, action);<br>        <br>        <span class="hljs-comment">// 答题人：小明 答案：鸡排</span><br>        <span class="hljs-comment">// 答题成功</span><br>        <span class="hljs-comment">// 答题人：小红 答案：奶茶</span><br>        <span class="hljs-comment">// 答题成功</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><p>委托是一对多的，也就是说，可以包装多个方法，当委托被调用时，会有多个方法被同时调用，调用的顺序则是方法被填入委托变量时的顺序。</p><p>在上述的例子进行扩展，再实例化一个 Logger，会提示【请继续答题】，并且使用 += 符号给 action 变量再添加一个方法引用。</p><p>此时回调方法会输出两行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// ...</span><br><br>        Logger logger1 = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">&quot;答题成功&quot;</span>);<br>        Logger logger2 = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">&quot;请继续答题&quot;</span>);<br>        Action action = <span class="hljs-keyword">new</span> Action(logger1.Log);<br>        action += logger2.Log;<br><br>        exam.AnswerQuestion(func1, action);<br>        exam.AnswerQuestion(func2, action);<br>        <br>        <span class="hljs-comment">// 答题人：小明 答案：鸡排</span><br>        <span class="hljs-comment">// 答题成功</span><br>        <span class="hljs-comment">// 请继续答题</span><br>        <span class="hljs-comment">// 答题人：小红 答案：奶茶</span><br>        <span class="hljs-comment">// 答题成功</span><br>        <span class="hljs-comment">// 请继续答题</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件是在委托的基础上，对委托的访问进行限制，事件的右侧只能是 += 或 -= 符号，不能被 = 符号直接覆盖，也不能被 .Invoke 调用。</p><p>接着上述的例子，自定义一个 SubmitEventHandler 委托，和一个 SubmitSystem 类。</p><p>SubmitSystem 类包含一个委托字段，和一个事件。</p><p>事件必须同时包含 add 和 remove，对委托字段进行添加方法和移除方法。</p><p>同时，因为委托字段是私有的，外部无法调用，事件也不能被调用，所以提供一个方法 TriggerSubmit 对委托字段进行调用。</p><blockquote><p>注意：如果 submitEventHandler 没有包含任何方法，则会是 null，需要进行判空。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SubmitEventHandler</span>(<span class="hljs-params"></span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubmitSystem</span><br>&#123;<br>    <span class="hljs-keyword">private</span> SubmitEventHandler submitEventHandler;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> SubmitEventHandler OnSubmit<br>    &#123;<br>        <span class="hljs-keyword">add</span><br>        &#123;<br>            submitEventHandler += <span class="hljs-keyword">value</span>;<br>        &#125;<br>        <span class="hljs-keyword">remove</span><br>        &#123;<br>            submitEventHandler -= <span class="hljs-keyword">value</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerSubmit</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (submitEventHandler != <span class="hljs-literal">null</span>)<br>        &#123;<br>            submitEventHandler.Invoke();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，继续添加主程序的逻辑。</p><p>实例化 submitSystem 变量，给它的事件添加两个方法，并通过 TriggerSubmit 调用被事件保护起来的私有委托。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        <br>        Logger logger3 = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">&quot;小明提交了试卷&quot;</span>);<br>        Logger logger4 = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">&quot;小红提交了试卷&quot;</span>);<br>        <br>        SubmitSystem submitSystem = <span class="hljs-keyword">new</span> SubmitSystem();<br>        submitSystem.OnSubmit += logger3.Log;<br>        submitSystem.OnSubmit += logger4.Log;<br>        <br>        submitSystem.TriggerSubmit();<br>        <br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 小明提交了试卷</span><br>        <span class="hljs-comment">// 小红提交了试卷</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述事件的定义是一个完整定义，实际上可以简化。</p><p>可以直接定义事件，无需定义私有委托字段，也无需为事件添加 add 和 remove 访问器。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SubmitEventHandler</span>(<span class="hljs-params"></span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubmitSystem</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> SubmitEventHandler OnSubmit;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerSubmit</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (OnSubmit != <span class="hljs-literal">null</span>)<br>        &#123;<br>            OnSubmit.Invoke();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，事件的右侧似乎可以被 .Invoke 调用，还可以判空。</p><p>实际上，因为 C# 会在编译时自动生成私有委托字段，但是编写代码时并没有私有委托字段，所以不得不使用事件来触发调用，不过外部对事件的访问依然只能是 += 和 -= 符号。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 基础语法 05 泛型集合</title>
    <link href="/2024/01/28/csharp-basic-5/"/>
    <url>/2024/01/28/csharp-basic-5/</url>
    
    <content type="html"><![CDATA[<p>简单复习一下 C# 基础语法（第五期）。</p><span id="more"></span><h1 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a>泛型集合</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是一个类型占位符，在定义泛型类的时候，可以先使用一个字母 T 占位，在实际使用时，需要传入一个具体的类型替代 T。</p><p>例如，定义一个泛型类，后面的尖括号 &lt; &gt; 先填 T，并且使用 T 声明一个变量 myType，在构造函数给 myType 赋值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGeneric</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T myType;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGeneric</span>(<span class="hljs-params">T type</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myType = type;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用时，需要填入具体的类型替代 T。</p><p>通过 myType 字段的 GetType 方法，查看它的数据类型。</p><p>填入 int 的泛型实例，它的 myType 字段的类型是 System.Int32。</p><p>填入 string 的泛型实例，它的 myType 字段的类型是 System.String。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        MyGeneric&lt;<span class="hljs-built_in">int</span>&gt; myGenericInt = <span class="hljs-keyword">new</span> MyGeneric&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>);<br>        Console.WriteLine(myGenericInt.myType.GetType());<br>        <span class="hljs-comment">// System.Int32</span><br><br>        MyGeneric&lt;<span class="hljs-built_in">string</span>&gt; myGenericString = <span class="hljs-keyword">new</span> MyGeneric&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;小明&quot;</span>);<br>        Console.WriteLine(myGenericString.myType.GetType());<br>        <span class="hljs-comment">// System.String</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，泛型类就可以通过填入不同的数据类型，提升代码的复用性，无需将类型写死。</p><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><p>列表是数组的扩展，内部实现是以数组为基础的。</p><p>列表的使用方法主要有：</p><ol><li>添加元素（Add）</li><li>访问元素（[]）</li><li>删除元素（Remove）</li><li>清空列表（Clear）</li></ol><p>使用 List 声明一个列表，尖括号 &lt; &gt; 内填入数据类型。</p><p>使用 Add 添加三个元素，并用 for 循环访问每个元素，打印输出。其中，Count 可以获取列表的长度。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; nums = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>        nums.Add(<span class="hljs-number">1</span>);<br>        nums.Add(<span class="hljs-number">2</span>);<br>        nums.Add(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.Count; i++)<br>        &#123;<br>            Console.WriteLine(nums[i]);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Remove 删除一个元素，后续的元素都会往前移动，列表长度减少。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; nums = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>        nums.Add(<span class="hljs-number">1</span>);<br>        nums.Add(<span class="hljs-number">2</span>);<br>        nums.Add(<span class="hljs-number">3</span>);<br>        nums.Remove(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.Count; i++)<br>        &#123;<br>            Console.WriteLine(nums[i]);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Clear 清空列表。</p><p>打印列表的长度，输出 0，表示列表中没有任何元素了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; nums = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>        nums.Add(<span class="hljs-number">1</span>);<br>        nums.Add(<span class="hljs-number">2</span>);<br>        nums.Add(<span class="hljs-number">3</span>);<br>        Console.WriteLine(nums.Count);<br>        <span class="hljs-comment">// 3</span><br>        <br>        nums.Clear();<br>        Console.WriteLine(nums.Count);<br>        <span class="hljs-comment">// 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h2><p>字典存储一系列键值对，通过 key 值，可以快速获取到对应的 value 值。</p><p>和列表类似，字典的使用方法主要有：</p><ol><li>添加元素（Add）</li><li>访问元素（[]）</li><li>删除元素（Remove）</li><li>判断是否包含某个 key 值（ContainsKey）</li><li>清空列表（Clear）</li></ol><p>使用 Dictionary 声明一个字典，尖括号 &lt; &gt; 内填入两个数据类型，第一个是 key，第二个是 value。</p><p>使用 Add 添加三个元素，记录每个学生的分数。</p><p>通过 [] 访问字典元素，填入 key 值获取 value 值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; scores = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br>        scores.Add(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">60</span>);<br>        scores.Add(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">80</span>);<br>        scores.Add(<span class="hljs-string">&quot;小坤&quot;</span>, <span class="hljs-number">100</span>);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;小明的分数：&quot;</span> + scores[<span class="hljs-string">&quot;小明&quot;</span>]);<br>        Console.WriteLine(<span class="hljs-string">&quot;小红的分数：&quot;</span> + scores[<span class="hljs-string">&quot;小红&quot;</span>]);<br>        Console.WriteLine(<span class="hljs-string">&quot;小坤的分数：&quot;</span> + scores[<span class="hljs-string">&quot;小坤&quot;</span>]);<br>        <br>        <span class="hljs-comment">// 小明的分数：60</span><br>        <span class="hljs-comment">// 小红的分数：80</span><br>        <span class="hljs-comment">// 小坤的分数：100</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Remove 删除某个 key 对应的元素之后，再次使用此 key 值去访问字典，则会报错。</p><p>所以通常要判断字典是否包含某个 key 值，才能去访问。</p><p>例如，从 scores 字典中删除小红的数据，如果直接访问 scores[“小红”] 会报错，需要使用 ContainsKey 判断一下是否包含小红的数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; scores = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br>        scores.Add(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">60</span>);<br>        scores.Add(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">80</span>);<br>        scores.Add(<span class="hljs-string">&quot;小坤&quot;</span>, <span class="hljs-number">100</span>);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;小明的分数：&quot;</span> + scores[<span class="hljs-string">&quot;小明&quot;</span>]);<br>        Console.WriteLine(<span class="hljs-string">&quot;小坤的分数：&quot;</span> + scores[<span class="hljs-string">&quot;小坤&quot;</span>]);<br><br>        scores.Remove(<span class="hljs-string">&quot;小红&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (scores.ContainsKey(<span class="hljs-string">&quot;小红&quot;</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;小红的分数：&quot;</span> + scores[<span class="hljs-string">&quot;小红&quot;</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Clear 清空字典。</p><p>字典同样有 Count 属性，获取字典的键值对的个数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; scores = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br>        scores.Add(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">60</span>);<br>        scores.Add(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">80</span>);<br>        scores.Add(<span class="hljs-string">&quot;小坤&quot;</span>, <span class="hljs-number">100</span>);<br>        Console.WriteLine(scores.Count);<br>        <span class="hljs-comment">// 3</span><br>        <br>        scores.Clear();<br>        Console.WriteLine(scores.Count);<br>        <span class="hljs-comment">// 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 基础语法 04 值和引用</title>
    <link href="/2024/01/21/csharp-basic-4/"/>
    <url>/2024/01/21/csharp-basic-4/</url>
    
    <content type="html"><![CDATA[<p>简单复习一下 C# 基础语法（第四期）。</p><span id="more"></span><h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><p>值类型，直接存储数据。</p><p>引用类型，存储内存地址，通过地址找到数据。</p><p>值类型：int，float，double，bool，char 等等。</p><p>引用类型：string，class 等等。</p><p>值类型赋值时，会创建值的副本。</p><p>修改值类型变量，不会影响其他值类型变量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> y = x;<br>        x = <span class="hljs-number">0</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;x = &quot;</span> + x);<br>        Console.WriteLine(<span class="hljs-string">&quot;y = &quot;</span> + y);<br>        <br>        <span class="hljs-comment">// x = 0</span><br>        <span class="hljs-comment">// y = 1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>引用类型，两个变量引用的对象相同时，对其中一个变量引用的对象进行修改，另一个变量引用的对象也发生了变化。</p><p>因为这两个变量只是存储了一个地址，指向同一块数据区域。</p><p>就好比，两个人使用同一个银行账户，一个人取走了全部的钱，另一个人就没钱了。</p><p>例如，有一个账户类，包含余额字段，存钱、取钱、查询余额的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Account</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Save</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> money</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (money &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.money += money;<br>            Console.WriteLine(<span class="hljs-string">&quot;存入 &quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> money</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (money &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.money &gt;= money)<br>            &#123;<br>                <span class="hljs-keyword">this</span>.money -= money;<br>                Console.WriteLine(<span class="hljs-string">&quot;取出 &quot;</span> + money);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;余额不足&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Query</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;余额 &quot;</span> + money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在创建一个账户对象，赋值给 myAccount，接着再赋值给 herAccount，两个 Account 变量引用的是同一个对象。</p><p>在我的账户存入 10 元，从她的账户取出 10 元，我的账户余额 0 元。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Account myAccount = <span class="hljs-keyword">new</span> Account();    <span class="hljs-comment">// 我的账户</span><br>        Account herAccount = myAccount;       <span class="hljs-comment">// 她的账户</span><br><br>        myAccount.Save(<span class="hljs-number">10f</span>);    <span class="hljs-comment">// 我的账户存入 10 元</span><br>        herAccount.Draw(<span class="hljs-number">10f</span>);   <span class="hljs-comment">// 她的账户取出 10 元</span><br>        myAccount.Query();      <span class="hljs-comment">// 我的账户余额  0 元</span><br>        <br>        <span class="hljs-comment">// 存入 10</span><br>        <span class="hljs-comment">// 取出 10</span><br>        <span class="hljs-comment">// 余额 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><p>装箱，把值类型转换成引用类型。</p><p>拆箱，把引用类型转换成值类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-built_in">object</span> obj = i;     <span class="hljs-comment">// 装箱</span><br>        <br>        <span class="hljs-built_in">int</span> j = (<span class="hljs-built_in">int</span>)obj;   <span class="hljs-comment">// 拆箱</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有时候为了通用，会把方法的参数类型定义为 object，当传入一个值类型参数时，就会需要装箱。</p><p>由于装箱会生成新的对象，对运行效率有一定影响，一般是尽量避免装箱和拆箱的。</p><p>装箱和拆箱时，对两个变量的值进行修改，是互不影响的。</p><h1 id="ref-和-out"><a href="#ref-和-out" class="headerlink" title="ref 和 out"></a>ref 和 out</h1><p>通常，当方法的参数是值类型时，外部传入的变量和方法体内的参数变量，是分别独立的，对方法体内的参数变量修改时，不会影响到外部的变量。</p><p>这是因为方法内的形参，只是外部传入的实参的一个副本。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        Add(i);<br>        Console.WriteLine(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>        <br>        <span class="hljs-comment">// i = 0</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要实现当 i 传入 Add 方法内，执行之后 i 的数值增加，则需要使用 ref 关键字。</p><p>方法的参数类型前面要加个 ref，调用方法时，传入的参数前面也要加个 ref。</p><p>此时，i 变成了按引用传参，在方法内对 i 进行修改，同时也会影响到外部的 i。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        Add(<span class="hljs-keyword">ref</span> i);<br>        Console.WriteLine(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>        <br>        <span class="hljs-comment">// i = 1</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> i</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，外部的 i 需要赋初始值，如果没有赋值，则会报错。</p><p>ref 的特点是有进有出，需要先赋值，再传入，有输出。</p><p>out 也是按引用传参，不过 out 只是用来输出多个参数。</p><p>out 的特点是只出不进，不需要先赋值，方法会把内部的数值输出到外部的变量，即使赋初始值，也会被输出的数值覆盖。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> i;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">3</span>;<br>        Add(<span class="hljs-keyword">out</span> i, <span class="hljs-keyword">out</span> j);<br>        Console.WriteLine(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>        Console.WriteLine(<span class="hljs-string">&quot;j = &quot;</span> + j);<br>        <br>        <span class="hljs-comment">// i = 1</span><br>        <span class="hljs-comment">// j = 2</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> j</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        i = <span class="hljs-number">1</span>;<br>        j = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 基础语法 03 面向对象</title>
    <link href="/2024/01/14/csharp-basic-3/"/>
    <url>/2024/01/14/csharp-basic-3/</url>
    
    <content type="html"><![CDATA[<p>简单复习一下 C# 基础语法（第三期）。</p><span id="more"></span><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>隐藏对象的信息，留出访问的接口，保护字段不被随意修改。</p><p>C# 的属性就是用来实现封装的。</p><p>例如，Hero 类有一个只读的等级属性，只能获取到英雄等级，而不能直接对等级进行修改。</p><p>如果要对英雄等级进行修改，只能通过给经验属性赋值，在类的内部进行经验和等级的转换。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span><br>&#123;<br>    <span class="hljs-comment">// 英雄等级 只读</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> level;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Level<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> level; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 经验等级转换</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> factor = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Experience<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> level * factor;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            level = Math.Abs(<span class="hljs-keyword">value</span> / factor);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建英雄对象，给他增加经验值，查看他的等级。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Hero hero = <span class="hljs-keyword">new</span> Hero();<br>        hero.Experience = <span class="hljs-number">10000</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;英雄等级：&quot;</span> + hero.Level);<br>        Console.WriteLine(<span class="hljs-string">&quot;英雄经验：&quot;</span> + hero.Experience);<br>        <br>        <span class="hljs-comment">// 英雄等级：10</span><br>        <span class="hljs-comment">// 英雄经验：10000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个类继承另一个类，它就拥有了另一个类的所有字段、属性和方法。</p><p>继承的类叫子类（或派生类），被继承的类叫父类（或基类）。</p><p>继承可以减少代码重复，提升代码的复用性。</p><p>现在出现了两位英雄，他们都继承了 Hero 类，并且类的内部没有定义任何成员字段、属性和方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 剑圣</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Blademaster</span> : <span class="hljs-title">Hero</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 大魔法师</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Archmage</span> : <span class="hljs-title">Hero</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>分别创建剑圣和大魔法师对象，给他们增加不同的经验值，查看他们的等级。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Blademaster blademaster = <span class="hljs-keyword">new</span> Blademaster();<br>        blademaster.Experience = <span class="hljs-number">10000</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;剑圣等级：&quot;</span> + blademaster.Level);<br>        Console.WriteLine(<span class="hljs-string">&quot;剑圣经验：&quot;</span> + blademaster.Experience);<br><br>        Archmage archmage = <span class="hljs-keyword">new</span> Archmage();<br>        archmage.Experience = <span class="hljs-number">20000</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;大魔法师等级：&quot;</span> + archmage.Level);<br>        Console.WriteLine(<span class="hljs-string">&quot;大魔法师经验：&quot;</span> + archmage.Experience);<br>        <br>        <span class="hljs-comment">// 剑圣等级：10</span><br>        <span class="hljs-comment">// 剑圣经验：10000</span><br>        <span class="hljs-comment">// 大魔法师等级：20</span><br>        <span class="hljs-comment">// 大魔法师经验：20000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是在继承的基础上，子类重写父类的方法，使用父类的类型声明变量，引用子类的实例对象，从而产生类型代差，调用同样的方法，却产生不一样的行为。</p><p>现在给英雄增加一个攻击的方法，这个方法需要使用 virtual 修饰符，是一个虚方法，表示可以被重写。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 英雄</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attack</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;英雄攻击&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让剑圣和大魔法师重写父类的攻击方法，重写方法需要使用 override 修饰符。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 剑圣</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Blademaster</span> : <span class="hljs-title">Hero</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attack</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;致命一击&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 大魔法师</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Archmage</span> : <span class="hljs-title">Hero</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attack</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;暴风雪&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，声明 Hero 类型的变量，引用不同类型的实例对象，调用 Attack。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 普通英雄</span><br>        Hero hero = <span class="hljs-keyword">new</span> Hero();<br>        hero.Attack();<br><br>        <span class="hljs-comment">// 剑圣</span><br>        Hero blademaster = <span class="hljs-keyword">new</span> Blademaster();<br>        blademaster.Attack();<br><br>        <span class="hljs-comment">// 大魔法师</span><br>        Hero archmage = <span class="hljs-keyword">new</span> Archmage();<br>        archmage.Attack();<br>        <br>        <span class="hljs-comment">// 英雄攻击</span><br>        <span class="hljs-comment">// 致命一击</span><br>        <span class="hljs-comment">// 暴风雪</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里之所以可以使用 Hero 变量引用 Blademaster 和 Archmage 对象，是因为他们继承了 Hero 类。</p><p>可以说剑圣是一个英雄，但反过来不行，英雄不一定是剑圣。</p><blockquote><p>如果反过来写，Blademaster blademaster = new Hero(); 则会报错：无法将类型 Hero 隐式转换为 Blademaster。</p><p>如果要强制类型转换，运行起来也会报错，无法将 Hero 强制转换为 Blademaster：Unhandled exception. System.InvalidCastException: Unable to cast object of type ‘Hero’ to type ‘Blademaster’.</p></blockquote><p>同时，也可以使用数组统一管理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Hero hero = <span class="hljs-keyword">new</span> Hero();<br>        Hero blademaster = <span class="hljs-keyword">new</span> Blademaster();<br>        Hero archmage = <span class="hljs-keyword">new</span> Archmage();<br><br>        Hero[] heros = &#123; hero, blademaster, archmage &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; heros.Length; i++)<br>        &#123;<br>            heros[i].Attack();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 英雄攻击</span><br>        <span class="hljs-comment">// 致命一击</span><br>        <span class="hljs-comment">// 暴风雪</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多态重写方法，实际上是在继承链上调用该方法的最新版本。</p><p>现在新增一个狂暴剑圣，继承了剑圣，也重写了 Attack 方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 狂暴剑圣</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BerserkBlademaster</span> : <span class="hljs-title">Blademaster</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attack</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;剑刃风暴&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟往常一样声明 Hero 类型变量，引用子类实例，调用方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Hero hero = <span class="hljs-keyword">new</span> Hero();<br>        Hero blademaster = <span class="hljs-keyword">new</span> Blademaster();<br>        Hero berserkBlademaster = <span class="hljs-keyword">new</span> BerserkBlademaster();<br>        <br>        hero.Attack();<br>        blademaster.Attack();<br>        berserkBlademaster.Attack();<br>        <br>        <span class="hljs-comment">// 英雄攻击</span><br>        <span class="hljs-comment">// 致命一击</span><br>        <span class="hljs-comment">// 剑刃风暴</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果狂暴剑圣没有重写 Attack 方法，而是声明了一个相同名字的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 狂暴剑圣</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BerserkBlademaster</span> : <span class="hljs-title">Blademaster</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attack</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;剑刃风暴&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么狂暴剑圣对象被 Hero 类型变量引用时，调用 Attack 方法，此时该方法被重写后的最新版本是剑圣的 Attack 方法，不会输出剑刃风暴，而是致命一击。</p><p>除非用狂暴剑圣本来的类型，才会输出剑刃风暴。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Hero hero = <span class="hljs-keyword">new</span> Hero();<br>        Hero blademaster = <span class="hljs-keyword">new</span> Blademaster();<br>        Hero berserkBlademaster = <span class="hljs-keyword">new</span> BerserkBlademaster();<br>        <br>        hero.Attack();<br>        blademaster.Attack();<br>        berserkBlademaster.Attack();<br>        <br>        <span class="hljs-comment">// 英雄攻击</span><br>        <span class="hljs-comment">// 致命一击</span><br>        <span class="hljs-comment">// 致命一击</span><br>        <br>        BerserkBlademaster berserkBlademaster2 = <span class="hljs-keyword">new</span> BerserkBlademaster();<br>        berserkBlademaster2.Attack();<br>        <br>        <span class="hljs-comment">// 剑刃风暴</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 基础语法 02 属性方法</title>
    <link href="/2024/01/07/csharp-basic-2/"/>
    <url>/2024/01/07/csharp-basic-2/</url>
    
    <content type="html"><![CDATA[<p>简单复习一下 C# 基础语法（第二期）。</p><span id="more"></span><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类包含字段、属性和方法，是一个抽象概念。</p><p>对象是类的一个实例。</p><h2 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h2><p>字段和属性定义了对象的特征。</p><p>声明一个学生类，包含若干个字段和属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender<br>&#123;<br>    Boy,<br>    Girl<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;    <span class="hljs-comment">// 姓名（公开）</span><br>    <span class="hljs-keyword">public</span> Gender gender;  <span class="hljs-comment">// 性别（公开）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;       <span class="hljs-comment">// 年龄（私有）</span><br><br>    <span class="hljs-comment">// 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">get</span> <span class="hljs-comment">// 可以获取年龄字段</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br>        <span class="hljs-keyword">set</span> <span class="hljs-comment">// 设置年龄字段时，可以添加逻辑判断，例如限制在 (0, 100) 之间</span><br>        &#123;<br>            <span class="hljs-comment">// value 是一个关键字，对属性进行赋值时，value 是等号右边的值</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">value</span> &lt; <span class="hljs-number">100</span>)<br>            &#123;<br>                age = <span class="hljs-keyword">value</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个学生对象，对字段和属性进行赋值，并打印结果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Student student = <span class="hljs-keyword">new</span> Student();<br>        student.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        student.gender = Gender.Boy;<br>        student.Age = <span class="hljs-number">200</span>;<br>        <br>        Console.WriteLine(student.name);    <span class="hljs-comment">// 小明</span><br>        Console.WriteLine(student.gender);  <span class="hljs-comment">// Boy</span><br>        Console.WriteLine(student.Age);     <span class="hljs-comment">// 0（对 Age 属性赋值时，数值不在规定范围内，age 字段默认值为 0）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法定义了对象的行为，可以执行一系列的逻辑。</p><h3 id="无参方法"><a href="#无参方法" class="headerlink" title="无参方法"></a>无参方法</h3><p>没有参数的方法。</p><p>例如，声明一个 Say 方法，打印三个句子。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Say</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;你好，我叫 &quot;</span> + name);<br>        Console.WriteLine(<span class="hljs-string">&quot;我是一个 &quot;</span> + gender);<br>        Console.WriteLine(<span class="hljs-string">&quot;我今年刚满 &quot;</span> + age + <span class="hljs-string">&quot; 岁~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实例对象调用方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Student student = <span class="hljs-keyword">new</span> Student();<br>        student.name = <span class="hljs-string">&quot;喵喵球&quot;</span>;<br>        student.gender = Gender.Girl;<br>        student.Age = <span class="hljs-number">18</span>;<br>        <br>        student.Say();<br>        <br>        <span class="hljs-comment">// 你好，我叫 喵喵球</span><br>        <span class="hljs-comment">// 我是一个 Girl</span><br>        <span class="hljs-comment">// 我今年刚满 18 岁~~~</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有参方法"><a href="#有参方法" class="headerlink" title="有参方法"></a>有参方法</h3><p>有参数的方法。</p><p>例如，声明一个 Repeat 方法，有一个 string 类型的参数，方法体内会复读传入的内容。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Repeat</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> content</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;我再说一遍 &quot;</span> + content);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实例对象调用方法，并传入一个字符串参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Student student = <span class="hljs-keyword">new</span> Student();<br><br>        student.Repeat(<span class="hljs-string">&quot;我今年刚满 18 岁~~~&quot;</span>);<br>        <br>        <span class="hljs-comment">// 我再说一遍 我今年刚满 18 岁~~~</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法的名称和类名相同。</p><p>当类里面没有写任何构造方法时，会有一个默认的无参构造方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-comment">// 无参构造方法，不写也行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在实例化对象时，有一些执行逻辑，就可以显式写出构造方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>Console.WriteLine(<span class="hljs-string">&quot;一个对象被实例化了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Student student = <span class="hljs-keyword">new</span> Student();<br>        <br>        <span class="hljs-comment">// 一个对象被实例化了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以自定义一个有参构造方法。</p><p>当参数名和字段名相同时，为了区分是参数赋值给字段，就需要在使用字段时，加上 this。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, Gender gender, <span class="hljs-built_in">int</span> age</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.gender = gender;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，私有字段 age 可以被直接赋值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, Gender.Boy, <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h3><p>当对象被垃圾收集器回收时，会自动调用析构方法。</p><p>析构方法也跟类名相同，前面要加个 ~ 符号。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    ~Student()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;我被回收了呜呜呜~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Program 类声明一个静态方法 CreateStudent，方法体内实例化一个对象，当方法调用结束后，对象就没有引用了。</p><p>此时可以调用 GC.Collect 方法主动回收一次垃圾，student 对象就会调用析构方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        CreateStudent();<br>        GC.Collect();<br>        <br>        <span class="hljs-comment">// 我被回收了呜呜呜~~~</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateStudent</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, Gender.Boy, <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>不用实例化对象就能调用的方法。</p><p>例如，上述的 CreateStudent 方法，前面有个修饰符 static，表示静态的，不需要 new 一个 Program 对象，就能够直接调用。</p><p>Student 类也可以声明一个静态方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Introduce</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;我是一个学生&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无需实例化对象，直接通过类名调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Student.Introduce();<br>        <br>        <span class="hljs-comment">// 我是一个学生</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 基础语法 01 入门概念</title>
    <link href="/2024/01/03/csharp-basic-1/"/>
    <url>/2024/01/03/csharp-basic-1/</url>
    
    <content type="html"><![CDATA[<p>简单复习一下 C# 基础语法（第一期）。</p><span id="more"></span><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 单行注释</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 多行注释</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 文档注释，会显示在代码提示框里</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 打印输出</span><br>Console.Write(<span class="hljs-string">&quot;输出&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;输出并换行&quot;</span>);<br><br><span class="hljs-comment">// 读取输入</span><br>Console.ReadLine();<br></code></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>在 C# 中被规定了用途的单词，声明变量时，变量名不可与关键字冲突。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-comment">// 命名空间</span><br><span class="hljs-title">using</span>     <span class="hljs-comment">// 引入命名空间</span><br><span class="hljs-title">class</span>     <span class="hljs-comment">// 声明类</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">char</span> gender = <span class="hljs-string">&#x27;男&#x27;</span>;      <span class="hljs-comment">// 字符型</span><br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;柯南&quot;</span>;    <span class="hljs-comment">// 字符串型</span><br><span class="hljs-built_in">int</span> age = <span class="hljs-number">3</span>;            <span class="hljs-comment">// 整型</span><br><span class="hljs-built_in">float</span> money = <span class="hljs-number">0.1f</span>;     <span class="hljs-comment">// 单精度浮点型</span><br><span class="hljs-built_in">double</span> salary = <span class="hljs-number">0.1</span>;    <span class="hljs-comment">// 双精度浮点型</span><br><span class="hljs-built_in">bool</span> hasMoney = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 布尔型</span><br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>声明并赋值，不可修改。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> PI = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>声明时可以赋值，如果没有赋值则会有相应类型的默认值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">double</span> money = <span class="hljs-number">0.1</span>;   <span class="hljs-comment">// 初始赋值</span><br><span class="hljs-built_in">int</span> num;              <span class="hljs-comment">// 默认值 0</span><br></code></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>低精度类型会自动转换成高精度类型</p><p>高精度类型需要强制转换成低精度类型，并且会丢失部分精度。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">double</span> i = <span class="hljs-number">2</span>;     <span class="hljs-comment">// 自动转换（隐式转换），int 转 double</span><br><span class="hljs-built_in">int</span> j = (<span class="hljs-built_in">int</span>)<span class="hljs-number">3.1</span>; <span class="hljs-comment">// 强制转换（显式转换），double 转 int，3.1 被转换成 3 再赋值给 j，丢失部分精度（小数点后的数字）</span><br></code></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举值是从 0 递增的整数。</p><p>使用枚举可以限制变量只能从有限的选项中取值，避免随意取值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 声明时</span><br><span class="hljs-built_in">enum</span> Gender <span class="hljs-comment">// 性别只能是男、女</span><br>&#123;<br>    Boy,<br>    Girl<br>&#125;<br><br><span class="hljs-comment">// 使用时</span><br>Gender.Boy<br>Gender.Girl<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] students = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 数组长度为 3</span><br><br><span class="hljs-comment">// 三个等效语句</span><br><span class="hljs-built_in">string</span>[] students1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> &#125;;  <span class="hljs-comment">// 直接赋值</span><br><span class="hljs-built_in">string</span>[] students2 = &#123; <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> &#125;;               <span class="hljs-comment">// 直接赋值</span><br><span class="hljs-built_in">string</span>[] students3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">3</span>] &#123; <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> &#125;; <span class="hljs-comment">// 数组长度为 3，并赋值</span><br><br>Console.WriteLine(students1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 输出 A</span><br></code></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[,] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>] &#123; &#123; <span class="hljs-number">11</span>, <span class="hljs-number">23</span> &#125;, &#123; <span class="hljs-number">25</span>, <span class="hljs-number">44</span> &#125;, &#123; <span class="hljs-number">76</span>, <span class="hljs-number">13</span> &#125; &#125;;  <span class="hljs-comment">// 3 行 2 列</span><br><span class="hljs-comment">// 11 23</span><br><span class="hljs-comment">// 25 44</span><br><span class="hljs-comment">// 76 13</span><br>Console.WriteLine(scores[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]); <span class="hljs-comment">// 取第一行第一列，结果 11</span><br>Console.WriteLine(scores[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]); <span class="hljs-comment">// 取第二行第二列，结果 44</span><br></code></pre></td></tr></table></figure><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">bool</span> hasMoney = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">bool</span> hasEnergy = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (hasMoney)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;买买买&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasEnergy)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;冲冲冲&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;发呆&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 发呆</span><br></code></pre></td></tr></table></figure><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;小樱&quot;</span>;<br><br><span class="hljs-keyword">switch</span> (name)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;小樱&quot;</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;魔法杖&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;知世&quot;</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;摄像机&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;未知&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 魔法杖</span><br></code></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过当次循环</span><br>    &#125;<br>    <span class="hljs-comment">// 打印 i</span><br>    Console.WriteLine(i);<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[] num = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> x <span class="hljs-keyword">in</span> num)<br>&#123;<br>    <span class="hljs-comment">// 打印 x</span><br>    Console.WriteLine(x);<br>    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 跳出循环</span><br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>)<br>&#123;<br>    <span class="hljs-comment">// 打印 i</span><br>    Console.WriteLine(i);<br>    i++;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do while 循环"></a>do while 循环</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 至少执行一次</span><br><span class="hljs-keyword">do</span><br>&#123;<br>    <span class="hljs-comment">// 打印 i</span><br>    Console.WriteLine(i);<br>    i++;<br>&#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 输入系统</title>
    <link href="/2023/10/05/unity-input-system/"/>
    <url>/2023/10/05/unity-input-system/</url>
    
    <content type="html"><![CDATA[<p>这篇文章研究一下通过键盘和鼠标对游戏物体进行移动或是其他操作。</p><p>先来看看简单的按键输入。</p><span id="more"></span><h2 id="一、键盘按键"><a href="#一、键盘按键" class="headerlink" title="一、键盘按键"></a>一、键盘按键</h2><p>创建一个脚本，挂载到一个 Cube 上，在 Update 函数监听键盘按键。</p><p>使用的接口就是 Input.GetKeyDown，这个接口只会在按下按键的时候，返回一次 true。也就是说，长按键盘按键时，后续只会返回 false。</p><p>如果想要按住键盘的按键，持续不断地返回 true，就可以使用 Input.GetKey 接口。</p><p>（注：Input.GetKey 在按下的瞬间，可能会调用好几次，因为 Update 是每帧执行一次，每帧 0.016 秒左右）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 按下键盘的 W 键，向上移动一个单位</span><br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.W))<br>    &#123;<br>        transform.position += Vector3.up;<br>    &#125;<br>    <span class="hljs-comment">// 按下键盘的 S 键，向下移动一个单位</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.S))<br>    &#123;<br>        transform.position += Vector3.down;<br>    &#125;<br>    <span class="hljs-comment">// 按下键盘的 A 键，向左移动一个单位</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.A))<br>    &#123;<br>        transform.position += Vector3.left;<br>    &#125;<br>    <span class="hljs-comment">// 按下键盘的 D 键，向右移动一个单位</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.D))<br>    &#123;<br>        transform.position += Vector3.right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，在移动游戏物体时，不会逐个按键去监听，而是使用 Input.GetAxis 去监听水平或垂直方向上的偏移量。</p><p>这里声明了一个速度和一个方向向量，通过获取水平和垂直方向的偏移量，修改方向向量，计算出每帧的移动距离，修改物体位置，达到通过键盘方向键移动游戏物体的目的。</p><p>上面通过监听每个键盘按键的例子，只对 WSAD 有效。而下面这个例子，对 WSAD 和 方向键 都有效。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed = <span class="hljs-number">5f</span>;<br><span class="hljs-keyword">public</span> Vector3 direction;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 水平偏移量</span><br>    <span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br>    <span class="hljs-comment">// 垂直偏移量</span><br>    <span class="hljs-built_in">float</span> v = Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>);<br>    <span class="hljs-comment">// 修改方向向量</span><br>    direction.x = h;<br>    direction.y = v;<br>    <span class="hljs-comment">// 计算移动距离并修改物体位置</span><br>    transform.position += speed * Time.deltaTime * direction;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么是 Horizontal 和 Vertical 呢？有没有其他的参数呢？</p><p>答案是有的。</p><p>打开 Edit -&gt; Project Settings -&gt; Input Manager，可以看到 Horizontal 和 Vertical 两个元素，里面都包含了一系列的参数设置。</p><p>可以添加、修改、删除一些元素，填好 Name（按键名）、Positive Button（正向）、Negative Button（反向）就可以通过 Input.GetAxis 获取按键输入啦。</p><p><img src="/../images/unity-input-system/Snipaste_2023-10-05_13-53-12.png"></p><p>此外，还有 Input.GetAxisRaw，它和 Input.GetAxis 的区别是，它的返回值是 -1 0 1 三个整数，而 Input.GetAxis 会逐渐从 0 到 1 或 -1 进行变化，有一个缓慢增速的过程。</p><p>除了 Input.GetKeyDown，还有 Input.GetButtonDown，它们都可以获取 Input Manager 设置的轴键，而 GetKeyDown 可以额外通过 KeyCode 枚举变量获取按键，GetButtonDown 则只能获取轴键（GetAxis 同理）。</p><h2 id="二、鼠标按键"><a href="#二、鼠标按键" class="headerlink" title="二、鼠标按键"></a>二、鼠标按键</h2><p>鼠标的三个按键也都是通过 Input 类的接口来监听。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">0</span>))<br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;按下鼠标左键&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">1</span>))<br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;按下鼠标右键&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">2</span>))<br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;按下鼠标中键&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>鼠标在屏幕上移动时，也同样可以获取到移动的坐标偏移量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">float</span> x = Input.GetAxis(<span class="hljs-string">&quot;Mouse X&quot;</span>);<br>    <span class="hljs-built_in">float</span> y = Input.GetAxis(<span class="hljs-string">&quot;Mouse Y&quot;</span>);<br>    Debug.Log(<span class="hljs-string">$&quot;mouse x = <span class="hljs-subst">&#123;x&#125;</span> y = <span class="hljs-subst">&#123;y&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>下面列出了一些常用的按键接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 键盘</span><br>Input.GetKey(KeyCode.W)           <span class="hljs-comment">// 按住 W 键持续返回 true, 松开后返回 false</span><br>Input.GetKeyDown(KeyCode.W)       <span class="hljs-comment">// 按下 W 键返回 true，按住也只会返回 false</span><br>Input.GetKeyUp(KeyCode.W)         <span class="hljs-comment">// 抬起 W 键返回 true</span><br><br><span class="hljs-comment">// 注：这里的 Jump 需要在 Input Manager 里设置一个名称为 Jump 的轴键</span><br>Input.GetButton(<span class="hljs-string">&quot;Jump&quot;</span>)           <span class="hljs-comment">// 按住自定义的键持续返回 true, 松开后返回 false</span><br>Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)       <span class="hljs-comment">// 按下自定义的键返回 true，按住也只会返回 false</span><br>Input.GetButtonUp(<span class="hljs-string">&quot;Jump&quot;</span>)         <span class="hljs-comment">// 抬起自定义的键返回 true</span><br><br>Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>)       <span class="hljs-comment">// AD 或左右方向键的偏移量 (从 0 到 1 变化，或从 0 到 -1 变化)</span><br>Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>)         <span class="hljs-comment">// WS 或上下方向键的偏移量 (从 0 到 1 变化，或从 0 到 -1 变化)</span><br>    <br>Input.GetAxisRaw(<span class="hljs-string">&quot;Horizontal&quot;</span>)    <span class="hljs-comment">// AD 或左右方向键的偏移量 (-1 0 1)</span><br>Input.GetAxisRaw(<span class="hljs-string">&quot;Vertical&quot;</span>)      <span class="hljs-comment">// WS 或上下方向键的偏移量 (-1 0 1)</span><br><br><br><span class="hljs-comment">// 鼠标 0: 左键  1: 右键  2: 中键</span><br>Input.GetMouseButton(<span class="hljs-number">0</span>)       <span class="hljs-comment">// 按住鼠标左键</span><br>Input.GetMouseButtonDown(<span class="hljs-number">1</span>)   <span class="hljs-comment">// 按下鼠标右键</span><br>Input.GetMouseButtonUp(<span class="hljs-number">2</span>)     <span class="hljs-comment">// 抬起鼠标中键</span><br><br>Input.GetAxis(<span class="hljs-string">&quot;Mouse X&quot;</span>)      <span class="hljs-comment">// 鼠标水平方向移动的偏移量</span><br>Input.GetAxis(<span class="hljs-string">&quot;Mouse Y&quot;</span>)      <span class="hljs-comment">// 鼠标垂直方向移动的偏移量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 移动游戏物体</title>
    <link href="/2023/09/12/unity-move-gameobject/"/>
    <url>/2023/09/12/unity-move-gameobject/</url>
    
    <content type="html"><![CDATA[<p>在 unity 中，一个很基础的需求是移动游戏物体。</p><p>移动物体的方式有很多种，本质上都是对 Transform 组件的 Position 属性进行修改。</p><span id="more"></span><h2 id="一、直接修改-position"><a href="#一、直接修改-position" class="headerlink" title="一、直接修改 position"></a>一、直接修改 position</h2><p>修改自身的位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>当前物体就会出现在指定的坐标位置。</p><p>修改引用物体的位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Transform other;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    other.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、Translate"><a href="#二、Translate" class="headerlink" title="二、Translate"></a>二、Translate</h2><p>unity 提供了 transform.Translate() 函数，用于移动游戏物体。</p><p>下面的例子是让当前物体沿着 X 轴正方向持续移动。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed = <span class="hljs-number">5f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    transform.Translate(Vector3.right * speed * Time.deltaTime, Space.World);<br>&#125;<br></code></pre></td></tr></table></figure><p>Translate 函数的第一个参数，就是移动的方向和距离，使用一个向量作为输入。</p><p>可以看到，这里使用了物体的右方向（Vector3.right），定义了一个速度（speed），乘上增量时间修正（Time.deltaTime），作为最终的移动向量。</p><p>为什么要乘上 Time.deltaTime 呢？</p><p>这是因为 Update 函数每秒的执行次数是根据设备的性能来决定的。如果当前帧率是 60，那么 Update 函数每秒执行 60 次；如果帧率是 30，则执行 30 次。那么，物体的移动速度就不稳定了。</p><p>为了保持物体在不同帧率下，都是同样的移动速度，Time.deltaTime 作为一个变量，就发挥作用了。</p><ul><li>在 60 帧的情况下，Time.deltaTime 的值为 1/60，Update 执行了 60 次，最终 1 秒移动了 Vector3.right * speed 的距离。</li><li>在 30 帧的情况下，Time.deltaTime 的值为 1/30，Update 执行了 30 次，最终 1 秒移动了 Vector3.right * speed 的距离。</li></ul><p>第二个参数是坐标系，默认是使用物体自身的局部坐标系，也可以指定使用世界坐标系（Space.World）。</p><h2 id="三、刚体"><a href="#三、刚体" class="headerlink" title="三、刚体"></a>三、刚体</h2><p>给物体挂上刚体组件（Rigidbody），修改 velocity 属性，让物体在指定的方向产生移动速度。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed = <span class="hljs-number">5f</span>;<br><span class="hljs-keyword">public</span> Rigidbody rigidbody;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    rigidbody.velocity = Vector3.right * speed;<br>&#125;<br></code></pre></td></tr></table></figure><p>刚体的速度只需要设置一次，就会持续不断地移动。</p><p>（注：刚体默认是受到重力影响，会往下掉落。如果想要让物体不受重力影响，可以取消勾选刚体组件上的 Use Gravity 选项。）</p><p>当然，在实际项目中，这个速度需要不断地进行调整，不会只在 Start 设置一次。</p><p>对于物理组件来说，通常会使用 FixedUpdate 去控制物理逻辑，对于一些按键输入，则可以使用 Update 控制。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 方向键左右的输入，取值为 -1, 0, 1</span><br>    <span class="hljs-built_in">float</span> horizontal = Input.GetAxisRaw(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br>    rigidbody.velocity = Vector3.right * horizontal * speed;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在物体就可以通过方向键进行左右移动了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顾博客</title>
    <link href="/2023/09/10/review-blog/"/>
    <url>/2023/09/10/review-blog/</url>
    
    <content type="html"><![CDATA[<p>已经有好久好久没有更新博客了。</p><p>我又回来看看它了。</p><span id="more"></span><p>最近经常看别人的博客，看到好多知识和有意思的想法，然后就会联想到自己以前建立的博客，感慨这两年间都没有再写上一篇博客。</p><p>其实平常都有在小米笔记上写一些工作日志、周志，还有偶尔的一些情绪感悟。</p><p>可能是因为手机上随时可以写，随时可以查看，就渐渐地遗忘了网页的博客吧。</p><p>而且我的主站是用 Notion 搭建的个人空间，博客对我来说，似乎确实没有太大的作用。</p><hr><p>回想当初，刚接触的编程语言是前端三件套（HTML、CSS、JavaScript），职业方向也是想着往 Web 前端开发工程师的路径走，只是由于自己的迷茫和懒惰，也有兴趣低迷的原因，导致这条路并没有走太远。</p><p>后来因为参加比赛，选择了做游戏，就一路走向了 Unity3D 客户端开发工程师。</p><p>那时候还是很纠结，是要做前端还是游戏。不过，听从了师兄的建议，尝试去做一个 Web 项目，最基本的，就是搭建一个博客。其实也算不上做项目吧，毕竟用了博客框架，看些入门教程就搭起来了，然后就是写文章。师兄也建议我去写一个 todolist 应用，不过那时候比赛很忙，后来也没写了。</p><p>最开始我写的博客，是全英文的。因为我想起来，以前师兄给我看过他的博客，也是全英文的。我觉得这样的写作方式可以一边积累博客一边熟练使用英语，所以就硬着头皮要求自己这样写了。当然，就坚持了两篇。</p><p>后面放弃了前端，也就遗忘了博客。</p><hr><p>第二次回来看博客，是 2021 年初的时候了。</p><p>那时候辞职考研失败，一切百废待兴，总觉得应该做点什么，并且需要记录一下自己的成长，让自己有一个全新的开始，所以就想起了博客。</p><p>那时候确实很兴奋地在写，还做了几个简单的小游戏，打包成 WebGL，捣鼓了很多天，终于可以在博客上预览了。</p><p>然后年初找工作，上班之后，就没时间没精力来写了。</p><hr><p>时间一晃，2023 年了。</p><p>这两年间也并不是一直有在工作，也换过几家公司，休息过几段时间。</p><p>现在，在新公司做了快七个月了，状态不是很好。说不出来什么原因，就是对工作内容和日常对接感到很无趣。</p><p>有自己的原因，也有其他人的原因。</p><p>总之，我需要找点事情来缓解一下自己的无趣。</p><hr><p>今天是 9 月 10 号，周日。</p><p>我参考了几个大佬的博客，很喜欢一个用 Jekyll 生成，Chirpy 主题的博客页面。</p><p>然后我捣鼓了一天 Ruby，安装 gem、bundler、jekyll，勉强看到了同样效果的页面，但是已经被 bundle 在命令行窗口半天都不响应给气晕了。</p><p>魔法上网、换镜像源，都很难制服这个 bundle，然后想想，还是 hexo 简单好用。</p><p>姑且用 hexo 写一篇简短的博客，来延续这个封印了两年的小空间吧。</p><hr><p>今天也给自己做的 hexo 主题美化了一下，做成了左边固定，右边滚动的结构。删除了很多没有用的元素，力求简洁。不过总感觉有点空，后续想到什么好玩的点子，再想办法加进来吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tetris</title>
    <link href="/2021/04/20/Tetris/"/>
    <url>/2021/04/20/Tetris/</url>
    
    <content type="html"><![CDATA[<p>俄罗斯方块项目演示。</p><p><a href="../../../../WebGL/Tetris/index.html">Tetris</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TheRestOfThePlanet</title>
    <link href="/2021/04/08/TheRestOfThePlanet/"/>
    <url>/2021/04/08/TheRestOfThePlanet/</url>
    
    <content type="html"><![CDATA[<p>星球余生项目演示。</p><p><a href="../../../../WebGL/TheRestOfThePlanet/index.html">TheRestOfThePlanet</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZerosSmartGrowth</title>
    <link href="/2021/02/17/ZerosSmartGrowth/"/>
    <url>/2021/02/17/ZerosSmartGrowth/</url>
    
    <content type="html"><![CDATA[<p>Zero 的智能成长项目演示。</p><p><a href="../../../../WebGL/ZerosSmartGrowth/index.html">ZerosSmartGrowth</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PickGifts</title>
    <link href="/2021/02/03/PickGifts/"/>
    <url>/2021/02/03/PickGifts/</url>
    
    <content type="html"><![CDATA[<p>挑选礼物项目演示。</p><p><a href="../../../../WebGL/PickGifts/index.html">PickGifts</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GreedySnake</title>
    <link href="/2021/01/27/GreedySnake/"/>
    <url>/2021/01/27/GreedySnake/</url>
    
    <content type="html"><![CDATA[<p>贪吃蛇项目演示。</p><p><a href="../../../../WebGL/GreedySnake/index.html">GreedySnake</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Link</title>
    <link href="/2021/01/27/Hexo-Link/"/>
    <url>/2021/01/27/Hexo-Link/</url>
    
    <content type="html"><![CDATA[<p>在文章中引入超链接，直接在 Typora 中写</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[GreedySnake](..<span class="hljs-regexp">/WebGL/</span>GreedySnake/index.html)<br></code></pre></td></tr></table></figure><p>这里的文件夹层级是，_posts 和 WebGL 都放在 source 里。</p><p>和插入图片一样，首页显示了链接，并且可以正常打开，而文章页面却不能正常打开，找不到页面。</p><p>同样是路径的问题。</p><span id="more"></span><p>在 Hexo-Image 这篇文章中，我使用了 hexo-renderer-marked 这个插件修改网站发布后的图片的路径。</p><p>不过，超链接这一块，我还没有找到合适的插件去修正。</p><p>所以这里就先用一个土方法，自己在路径前加上很多个 ../ 。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[GreedySnake](..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>WebGL<span class="hljs-regexp">/GreedySnake/i</span>ndex.html)<br></code></pre></td></tr></table></figure><p>加多少个，要看文件夹的层级，根据实际情况去选择。这里我加上了三个 ../ ，因为我的文章页面的上级目录，有年月日三个层级。</p><p>这样，文章页面的超链接路径就会回到根目录下去找 WebGL 这个文件夹，而主页同样是在根目录下找，因为根目录已经没有上级目录了，所以加多少个 ../ 也没关系（好像有点矛盾了）。</p><p>不过，我觉得这个方法并不是最好的，以后估计会找到更好的解决方案吧。</p><p>另外，超链接的路径里不能有空格，如果有空格，超链接会变成 p 标签。</p><p>还有一个问题，就是 index.html 在发布时会被渲染，导致页面出现某些问题。比如，我打开的链接是 Unity WebGL 的页面，这个页面会直接在我的网站背景上显示，而不是打开一个新的页面。</p><p><img src="/../images/HexoLink/page_overlap.png" alt="页面重叠"></p><p>所以还需要去到 config.yml 文件里，找到 skip_render，让一些页面跳过渲染。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">skip_render:<br>  -<span class="ruby"> <span class="hljs-string">&#x27;README.md&#x27;</span></span><br><span class="ruby">  - <span class="hljs-string">&#x27;WebGL/GreedySnake/*.html&#x27;</span></span><br></code></pre></td></tr></table></figure><p>参数前加的连字符 - 是 yml 的数组写法。这里我添加了 GreedySnake 下的所有 html 文件。</p><p>清理一下数据库，清理之前，如果 public 文件夹下的有需要保存的东西，比如 README.md，需要先备份一下，因为清理的命令也会把 public 文件夹给删除。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>重新启动本地服务器，会发现，WebGL 页面已经在新页面打开了。</p><p><img src="/../images/HexoLink/new_page.png" alt="打开新页面"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Image</title>
    <link href="/2021/01/27/Hexo-Image/"/>
    <url>/2021/01/27/Hexo-Image/</url>
    
    <content type="html"><![CDATA[<p>在写文章的过程中，有时需要插入图片。</p><p>如果直接在 Markdown 文件中使用相对路径引用图片，当网站发布时，首页显示了图片，文章页面却不会显示图片。</p><p>经过一番探索和尝试，我使用以下的方法插入图片。</p><span id="more"></span><p>首先，在 source 文件夹下创建一个 images 文件夹。</p><p>为了便于分类，在 images 文件夹下，还有一个 Hexo 文件夹，表示这个文件夹下的图片是 Hexo.md 这篇文章使用的。</p><p><img src="/../images/HexoImage/imagesHexo.png" alt="Hexo文章里的图片"></p><p>接着，在 Typora 编辑器中插入图片，例如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">![创建仓库](..<span class="hljs-regexp">/images/</span>Hexo/repository.png)<br></code></pre></td></tr></table></figure><p>在输入图片路径时，要使用 / 而不是 \，虽然两种写法在 Typora 编辑器中都可以显示图片，但是在 Hexo 发布时却会导致路径出现问题。</p><p>另外，图片和文件夹的名称也不能带有连字符 - ，因为这个符号同样会让图片显示不出来。</p><p>然后，安装一个插件。这个插件也是为了让文章被渲染后的图片路径变得正常。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-renderer-marked <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>在 config.yml 里配置一下，找到 Writing 这个标题下，新增字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>还要检查一下 URL 这个标题下，root 字段是否是一个斜杠</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">root:</span> /<br></code></pre></td></tr></table></figure><p>这个 prependRoot 字段的作用是，在图片的路径前，加上 root 设置的路径。</p><p>在这里，因为我设置的图片路径是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">![创建仓库](..<span class="hljs-regexp">/images/</span>Hexo/repository.png)<br></code></pre></td></tr></table></figure><p>按照上述的配置，生成的页面的图片路径就会变成</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">![创建仓库](<span class="hljs-regexp">/../im</span>ages<span class="hljs-regexp">/Hexo/</span>repository.png)<br></code></pre></td></tr></table></figure><p>原本发布后，文章页面的图片路径应该是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span><span class="hljs-regexp">/2021/</span><span class="hljs-number">01</span><span class="hljs-regexp">/26/im</span>ages<span class="hljs-regexp">/Hexo/</span>repository.png<br></code></pre></td></tr></table></figure><p>就是路径的问题导致文章页面的图片显示不出来，而配置后的路径则是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span><span class="hljs-regexp">/images/</span>Hexo/repository.png<br></code></pre></td></tr></table></figure><p>路径正确，图片也就正常地显示出来了。</p><p>不过此处有个小问题，就是按照上述流程配置后，文章的图片还是显示不出来，经过测试发现，需要在文章里写一次</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--more--&gt;</span> // 首页会出现 Read More 的按钮，隐藏后面的内容<br></code></pre></td></tr></table></figure><p>然后神奇的是，图片正常显示了。</p><p>之后，即使把这个代码去掉，图片也是正常显示的。</p><p>可能是这个插件的某个地方出了问题吧。</p><p>如果直接写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--more--&gt;</span><br></code></pre></td></tr></table></figure><p>也是显示不出来的，还是需要先安装插件，配置 config.yml，再写 Read More 的代码才行。</p><p>最后，生成一下页面。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><p>在本地测试一下，可以看到图片已经显示出来了。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p><img src="/../images/HexoImage/imagesTest.png" alt="本地测试"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Config</title>
    <link href="/2021/01/27/Hexo-Config/"/>
    <url>/2021/01/27/Hexo-Config/</url>
    
    <content type="html"><![CDATA[<p>在根目录下，有个叫 _config.yml 的文件，用文本编辑器打开，可以看到很多配置字段。</p><span id="more"></span><h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>title</td><td>网站的标题</td><td>默认会显示在网站顶部</td></tr><tr><td>subtitle</td><td>网站的副标题</td><td>默认会显示在标题下方</td></tr><tr><td>description</td><td>网站的描述</td><td>没有显示，跟搜索引擎有关</td></tr><tr><td>keywords</td><td>网站的关键词</td><td>没有显示，跟搜索引擎有关</td></tr><tr><td>author</td><td>作者</td><td>默认会显示在网站底部</td></tr><tr><td>language</td><td>网站的语言，使用 2 个字符的代码描述，中文是 zh</td><td>没有显示，跟搜索引擎有关</td></tr><tr><td>timezone</td><td>网站的时区，Hexo会默认使用计算机上的设置</td><td>没有显示，跟搜索引擎有关</td></tr></tbody></table><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>url</td><td>网站的 URL</td><td>如果网站在域名下的一个子目录里，则需要设置为 https://网址/子目录/</td></tr><tr><td>root</td><td>网站的根目录</td><td>如果网站在域名下的一个子目录里，则需要设置为 /子目录/</td></tr><tr><td>permalink</td><td>文章的永久链接格式</td><td>public 文件夹和网址的层级格式</td></tr><tr><td>permalink_defaults</td><td>永久链接格式的默认值</td><td>为 permalink 设置默认值</td></tr><tr><td>pretty_urls</td><td>美化永久链接</td><td>可以让 URL 更简洁</td></tr><tr><td>pretty_urls.trailing_index</td><td>链接尾部的 index.html</td><td>设置为 false 可以让链接尾部的 index.html 不显示</td></tr><tr><td>pretty_urls.trailing_html</td><td>链接尾部的 .html</td><td>设置为 false 可以让链接尾部的 .html 不显示</td></tr></tbody></table><h1 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>source_dir</td><td>资源文件夹</td><td>存放文章、图片等资源</td></tr><tr><td>public_dir</td><td>Hexo 发布的文件夹</td><td>可以看到发布后的静态页面文件</td></tr><tr><td>tag_dir</td><td>标签文件夹</td><td>给文章设置标签后，会多出一个标签文件夹，网站的侧边栏也会多出两栏标签导航栏</td></tr><tr><td>archive_dir</td><td>档案文件夹</td><td>默认按照月份将文章归档</td></tr><tr><td>category_dir</td><td>分类文件夹</td><td>跟标签文件夹差不多，同样在文章的顶部进行设置</td></tr><tr><td>code_dir</td><td>代码文件夹</td><td>存放代码</td></tr><tr><td>i18n_dir</td><td>国际化文件夹</td><td>跟语言相关</td></tr><tr><td>skip_render</td><td>跳过渲染，将路径下的文件直接拷贝到 public 文件夹下</td><td>可以在发布时，将一些资源原封不动地拷贝到 public 文件夹，避免渲染后出现问题，比如 README.md 文件</td></tr></tbody></table><h1 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>new_post_name</td><td>新建文章的名称格式，默认是 title.md</td><td>新建文章后生成的文件名会是 标题.md 的格式</td></tr><tr><td>default_layout</td><td>新建文章的默认布局，默认是 post</td><td>新建文章时使用的模板</td></tr><tr><td>titlecase</td><td>将标题转换成首字母大写的标题</td><td></td></tr><tr><td>external_link</td><td>外部链接</td><td></td></tr><tr><td>external_link.enable</td><td>是否在新标签页打开外部链接</td><td></td></tr><tr><td>external_link.field</td><td>对整个网站还是当前文章生效</td><td></td></tr><tr><td>external_link.exclude</td><td>排除哪些域名</td><td></td></tr><tr><td>filename_case</td><td>把文章的名称改为小写（1）或大写（2），默认不改（0）</td><td></td></tr><tr><td>render_drafts</td><td>是否渲染草稿</td><td>设置为 true 后，将会显示通过草稿模板创建的文章</td></tr><tr><td>post_asset_folder</td><td>是否启用资源文件夹</td><td>设置为 true 后，新建文章的同时，会在文章同级目录下生成一个同名文件夹存放资源</td></tr><tr><td>relative_link</td><td>是否把链接改为根目录的相对路径</td><td></td></tr><tr><td>future</td><td>是否显示未来日期的文章</td><td>设置为 false 后，将不会显示未来日期的文章</td></tr><tr><td>highlight</td><td>代码块设置</td><td></td></tr><tr><td>highlight.enable</td><td></td><td></td></tr><tr><td>highlight.line_number</td><td></td><td></td></tr><tr><td>highlight.auto_detect</td><td></td><td></td></tr><tr><td>highlight.tab_replace</td><td></td><td></td></tr><tr><td>highlight.wrap</td><td></td><td></td></tr><tr><td>highlight.hljs</td><td></td><td></td></tr><tr><td>prismjs</td><td>代码块设置</td><td></td></tr><tr><td>prismjs.enable</td><td></td><td></td></tr><tr><td>prismjs.preprocess</td><td></td><td></td></tr><tr><td>prismjs.line_number</td><td></td><td></td></tr><tr><td>prismjs.tab_replace</td><td></td><td></td></tr></tbody></table><h1 id="Home-page-setting"><a href="#Home-page-setting" class="headerlink" title="Home page setting"></a>Home page setting</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>index_generator</td><td>主页设置</td><td></td></tr><tr><td>index_generator.path</td><td>主页的路径</td><td></td></tr><tr><td>index_generator.per_page</td><td>每页显示的文章数目</td><td></td></tr><tr><td>index_generator.order_by</td><td>文章排序</td><td></td></tr></tbody></table><h1 id="Category-amp-Tag"><a href="#Category-amp-Tag" class="headerlink" title="Category &amp; Tag"></a>Category &amp; Tag</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>default_category</td><td>默认分类</td><td></td></tr><tr><td>category_map</td><td>分类别名</td><td></td></tr><tr><td>tag_map</td><td>标签别名</td><td></td></tr></tbody></table><h1 id="Metadata-elements"><a href="#Metadata-elements" class="headerlink" title="Metadata elements"></a>Metadata elements</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>meta_generator</td><td>是否在页面头部插入 meta 标签</td><td></td></tr></tbody></table><h1 id="Date-Time-format"><a href="#Date-Time-format" class="headerlink" title="Date / Time format"></a>Date / Time format</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>date_format</td><td>日期格式</td><td></td></tr><tr><td>time_format</td><td>时间格式</td><td></td></tr><tr><td>updated_option</td><td>如果文章中没有指定创建日期，就会使用更新日期</td><td></td></tr></tbody></table><h1 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>per_page</td><td>文章分页时，每页的文章数目</td><td></td></tr><tr><td>pagination_dir</td><td>分页的目录</td><td></td></tr></tbody></table><h1 id="Include-Exclude-file-s"><a href="#Include-Exclude-file-s" class="headerlink" title="Include / Exclude file(s)"></a>Include / Exclude file(s)</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>include</td><td>包括的文件</td><td>Hexo 会将这个路径下的文件拷贝到 source 文件夹下</td></tr><tr><td>exclude</td><td>不包括的文件</td><td>Hexo 会将这个路径下的文件排除在外</td></tr><tr><td>ignore</td><td>忽略的文件</td><td>Hexo 不会对这些文件进行操作</td></tr></tbody></table><h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>theme</td><td>主题</td><td>网站显示的样式</td></tr></tbody></table><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><table><thead><tr><th>字段</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>deploy</td><td>部署设置</td><td></td></tr><tr><td>deploy.type</td><td>部署类型，默认是 git</td><td></td></tr><tr><td>deploy.repo</td><td>部署地址，github 远程仓库地址</td><td>将发布后的文件部署到相应的 Github 地址</td></tr><tr><td>deploy.branch</td><td>部署分支</td><td>将发布后的文件部署到相应的 Github 地址的一个分支下</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2021/01/26/Hexo/"/>
    <url>/2021/01/26/Hexo/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是一个网站框架，可以快速地搭建一个属于自己的网站。</p><p>下面介绍一下我的搭建过程。</p><span id="more"></span><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>注册一个 Github 账号并创建远程仓库</li><li>安装 Git</li><li>安装 node.js</li><li>配置 SSH Key</li></ul><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>Github 官网：<a href="https://github.com/">https://github.com/</a></p><p>点击右上角的 sign up 注册一个账号。</p><p>登录后，在 Github 上 new 一个 repository，名字叫做：github昵称 + github.io。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">weikunou</span><span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Hexo/repository.png" alt="创建仓库"></p><p>创建好之后，点击分支按钮，输入 source，创建一个新的分支，用于存储源文件。</p><p><img src="/../images/Hexo/source.png" alt="创建source分支"></p><p>而默认的 main 分支是用来存储发布后的静态页面文件的。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Git 官网： <a href="https://git-scm.com/">https://git-scm.com/</a></p><p>Node.js 官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><h2 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h2><p>这个是用来提交代码到远程仓库的密钥，可以安全地将本地文件上传到 Github 服务器。</p><p>打开 Git Bash，输入如下代码，先检查一下本机是否已经有 SSH Key：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br></code></pre></td></tr></table></figure><p>如果提示 No such file or directory 则说明没有 SSH Key。</p><p>那么，输入如下代码创建 SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;注册 Github 的邮箱地址&quot;</span><br></code></pre></td></tr></table></figure><p>如果保持默认设置，可以直接连续按回车键。完成配置后，打开 C 盘里的用户文件夹，可以看到一个 .ssh 的文件夹，用文本编辑器打开 id_rsa.pub，复制所有的内容。</p><p>回到 Github 主页，点击右上角的头像，点击 Settings，进入设置页面，找到 SSH and GPG keys，点击 New SSH key 按钮，Title 可以随意起，把复制的内容粘贴到 Key 的文本框内，最后点击 Add SSH key。</p><p><img src="/../images/Hexo/ssh.png" alt="ssh"></p><p>然后，测试一下是否配置成功。回到 Git Bash 面板，输入代码：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>如果有提示</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi weikunou! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>就说明已经配置成功了。</p><p>另外，还需要配置一下 Git 的用户名和邮箱，用来记录每次提交代码的人是谁。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;github 用户名&quot;</span><br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;github 注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>在 Git Bash 窗口（或者 cmd 命令提示符窗口），输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><p>就安装好了 Hexo。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在电脑的某个盘上准备好要存放 Hexo 的文件夹，比如 myblog。</p><p>然后在 Git Bash 窗口下转到目录，比如 D 盘上的 Projects 文件夹下的 myblog 子文件夹。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ cd <span class="hljs-regexp">/d/</span>Projects/myblog<br></code></pre></td></tr></table></figure><p>然后执行初始化命令。如果文件夹不是空的，则会报错，需要保持 myblog 是一个空文件夹。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>此时 myblog 文件夹下就有了一些文件。耐心等待一段时间，Hexo 会自动安装 node_modules 依赖包，如果没有发现这个文件夹，那么可以输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>手动安装 node_modules 依赖包。</p><p>接下来，执行</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务，然后打开浏览器，在地址栏输入 http:// localhost:4000/ 即可在本地预览网站。</p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>执行</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;About-me&quot;</span><br></code></pre></td></tr></table></figure><p>hexo 会在 source/_posts 文件夹下生成一个新的 About-me.md 文件，打开这个文件，就可以开始写作啦。</p><p>这里推荐一款 Markdown 写作软件，<a href="https://www.typora.io/">Typora</a>。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>安装一个插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>用文本编辑器打开 Hexo 文件夹下的 _config.yml，在最下面的 deploy 参数下，填写远程仓库的名称和分支。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: git<br>  <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/Github 用户名/Github 项目名</span><br>  <span class="hljs-attribute">branch</span>: main<br></code></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>就将项目发布成静态页面并上传到 Github 项目的 main 分支下了。</p><p>现在，只要在浏览器输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>Github项目名称/<br></code></pre></td></tr></table></figure><p>就可以访问个人网站啦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
